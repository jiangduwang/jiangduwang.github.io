<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>顾涛的八股</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="顾涛的八股">
<meta property="og:url" content="https://jiangduwang.github.io/index.html">
<meta property="og:site_name" content="顾涛的八股">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="jiangduwang">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="顾涛的八股" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">顾涛的八股</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://jiangduwang.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-网络" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/03/%E7%BD%91%E7%BB%9C/" class="article-date">
  <time class="dt-published" datetime="2024-06-03T05:49:33.350Z" itemprop="datePublished">2024-06-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/06/03/%E7%BD%91%E7%BB%9C/">网络八股</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="网络分层模型"><a href="#网络分层模型" class="headerlink" title="网络分层模型"></a>网络分层模型</h2><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/osi-7-model.png" alt="OSI 七层模型"></p>
<h3 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP&#x2F;IP四层模型"></a>TCP&#x2F;IP四层模型</h3><ol>
<li>应用层（应用层、表示层、会话层）</li>
<li>传输层</li>
<li>网络层</li>
<li>网络接口层（数据链路层、物理层）</li>
</ol>
<h2 id="常见网络协议"><a href="#常见网络协议" class="headerlink" title="常见网络协议"></a>常见网络协议</h2><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><ul>
<li>HTTP超文本传输协议</li>
<li>SMTP简单邮件发送协议</li>
<li>FTP文件传输协议</li>
<li>Telnet远程登陆协议</li>
<li>SSH网络传输协议</li>
<li>RTP实时传输协议</li>
<li>DNS域名管理系统，用于解决域名和IP地址的映射问题</li>
</ul>
<p>前面5个协议都是基于TCP，RTP通常基于UDP，也支持TCP，DNS基于UDP</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><ul>
<li>TCP    面向连接的可靠传输</li>
<li>UDP   无连接的数据传输</li>
</ul>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><ul>
<li>IP网络协议</li>
<li>ARP地址解析协议    网络层地址和链路层地址之间的转换问题</li>
<li>ICMP互联网控制报文协议      传输网络状态和错误消息的协议</li>
<li>NAT网络地址转换协议</li>
<li>OSPF开放式最短路径协议 </li>
<li>RIP路由信息协议</li>
<li>BGP边界网关协议</li>
</ul>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="打开一个网站，会用到哪些协议？"><a href="#打开一个网站，会用到哪些协议？" class="headerlink" title="打开一个网站，会用到哪些协议？"></a>打开一个网站，会用到哪些协议？</h3><ol>
<li>在浏览器中输入网页的URL</li>
<li>浏览器通过DNS协议，获取域名对应的IP地址；</li>
<li>浏览器根据IP和端口号，向目标服务器发起一个TCP请求</li>
<li>浏览器在TCP连接上，向服务器发送一个HTTP请求，请求获取网页的内容</li>
<li>服务器收到HTTP请求后，会发一个HTTP响应报文给浏览器</li>
<li>浏览器收到HTTP响应后，解析响应体中的HTML样式，同时根据HTML中其他资源（图片、CSS、js）的URL再次发起HTTP请求，直至网页资源全部加载</li>
</ol>
<h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><ul>
<li>1XX        接收的请求正在处理</li>
<li>2XX        请求正常处理完毕</li>
<li>3XX        需要进行附加操作来完成请求</li>
<li>4XX        服务器无法处理请求</li>
<li>5XX        服务端处理请求出错</li>
</ul>
<h3 id="HTTP和HTTPS有什么区别"><a href="#HTTP和HTTPS有什么区别" class="headerlink" title="HTTP和HTTPS有什么区别"></a>HTTP和HTTPS有什么区别</h3><ul>
<li>端口号：HTTP默认是80，HTTPs默认是443</li>
<li>URL前缀</li>
<li>安全性：HTTPS运行在SSL&#x2F;TLS协议上，SSL&#x2F;TLS运行在TCP上，所有传输的内容都经过加密。</li>
</ul>
<h3 id="HTTP如何保存用户状态"><a href="#HTTP如何保存用户状态" class="headerlink" title="HTTP如何保存用户状态"></a>HTTP如何保存用户状态</h3><p>session可以通过服务端记录用户的状态，可以给特定的用户创建特定的session来进行标识。</p>
<p>服务端保存session的方法，可以通过内存和数据库实现。</p>
<p>服务端跟踪session的方法，在cookie中附加一个session id来跟踪。</p>
<p>如果cookie被禁就直接将session id直接附加在url路径的后面。</p>
<h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><ul>
<li>GET通常用于获取或查询资源，POST用于创建或修改资源；</li>
<li>GET是幂等的，POST是不幂等的</li>
<li>GET请求的参数放在URL中，POST请求的参数放在请求体中</li>
<li>GET可以被缓存，POST不行</li>
</ul>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>基于TCP连接的全双工通信协议，客户端和服务端可以同时发送和接收数据。</p>
<p>应用：实时弹幕、社交聊天</p>
<h2 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h2><p>用来测试网络中主机之间的连通性和网络延迟</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>基于网络层的ICMP协议，通过在网络上发送和接收ICMP报文实现。</p>
<p>PING会向目标主机发送ICMP请求报文，如果两个主机连通性正常，目标主机会返回一个对象的ICMP响应报文；</p>
<p>PING会计算请求和接收ICMP报文的时间间隔，用来衡量网络连接的延迟。</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>解决域名和IP的映射问题</p>
<p>如果一个域名在浏览器缓存、操作系统缓存或者DNS缓存中时，直接使用缓存中的IP地址；缓存中都没有，就会用到DNS的域名系统</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><table>
<thead>
<tr>
<th></th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td>是否面向连接</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否可靠</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否有状态</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>传输效率</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>传输形式</td>
<td>字节流</td>
<td>数据报文段</td>
</tr>
<tr>
<td>首部开销</td>
<td>20-60 bytes</td>
<td>8bytes</td>
</tr>
<tr>
<td>是否支持多播或广播</td>
<td>点对点</td>
<td>一对一，一对多，多对多</td>
</tr>
<tr>
<td>应用</td>
<td>文件传输、远程登录</td>
<td>即时通信、直播</td>
</tr>
</tbody></table>
<h3 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a>TCP的三次握手和四次挥手</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ol>
<li>客户端向服务端发送一个SYN(SEQ &#x3D; x)的请求报文；</li>
<li>服务端在接收之后向客户端发送一个SYN(SEQ&#x3D;y)和一个ACK(ACK &#x3D; x+1)报文；</li>
<li>客户端在接收之后向服务端发送一个ACK(ACK&#x3D;y+1)报文。</li>
</ol>
<p>第一次握手之后，服务端确定了客户端发送正常，自己接收正常；</p>
<p>第二次握手之后，客户端确定了自己发送和接收正常，服务端接收和发送正常，服务端确定了自己接收正常，客户端发送正常；</p>
<p>第三次握手之后，客户端确定了自己发送和接收正常，服务端接收和发送正常，服务端确定了自己发送和接收正常，客户端发送和接收正常；</p>
<p>建立连接。</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><ol>
<li>客户端向服务端发送一个FIN(SEQ&#x3D;x)的请求报文；</li>
<li>服务端在接收之后向客户端发送一个ACK(ACK&#x3D;x+1)报文；</li>
<li>服务端向客户端发送一个FIN(SEQ&#x3D;y)的请求报文；</li>
<li>客户端在接收之后向服务端发送一个ACK(ACK&#x3D;y+1)报文，客户端等待若干时间，若服务端无响应，则关闭连接。</li>
</ol>
<p>前两次挥手是客户端表明要断开连接，后两次挥手是服务端确定要断开连接。</p>
<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h3 id="IPv4-和-IPv6"><a href="#IPv4-和-IPv6" class="headerlink" title="IPv4 和 IPv6"></a>IPv4 和 IPv6</h3><p>IPv4：四组由点分隔的数字，每个数字8位，一共32位。</p>
<p>IPv6：单或双冒号分割的一组数字或字母，一共128位</p>
<h3 id="NAT的作用"><a href="#NAT的作用" class="headerlink" title="NAT的作用"></a>NAT的作用</h3><p>将私有IP地址比如局域网中的地址映射为公有IP地址。</p>
<h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><h3 id="Mac地址"><a href="#Mac地址" class="headerlink" title="Mac地址"></a>Mac地址</h3><p>一切网络设备都由MAC地址唯一标识，MAC地址是一个网络设备的真正标识，IP地址只是一种不重复的定位方式。</p>
<p>Mac地址长度6字节。</p>
<h3 id="ARP的作用"><a href="#ARP的作用" class="headerlink" title="ARP的作用"></a>ARP的作用</h3><p>解决了网络层地址和链路层地址之间的转换问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jiangduwang.github.io/2024/06/03/%E7%BD%91%E7%BB%9C/" data-id="clwyjx9fk0004jkulelix9nze" data-title="网络八股" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据库" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/03/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="article-date">
  <time class="dt-published" datetime="2024-06-03T05:49:33.277Z" itemprop="datePublished">2024-06-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/06/03/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库八股</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h2><h3 id="常用词"><a href="#常用词" class="headerlink" title="常用词"></a>常用词</h3><ul>
<li>元组：数据库表中的每行</li>
<li>码：能唯一标识实体的属性</li>
<li>候选码：某一属性或者属性组能唯一的标识一个元组，并且其子集不能再标识</li>
<li>主码：主键，能唯一标识一个元组</li>
<li>外码：一个关系中一个属性是另一个关系中的主码</li>
<li>主属性：候选码中出现的属性</li>
</ul>
<h3 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h3><ul>
<li>实体：业务对象，用矩形框表示</li>
<li>属性：实体的属性，用椭圆形表示</li>
<li>联系：实体与实体之间的关系，用菱形表示</li>
</ul>
<p><img src="https://oss.javaguide.cn/github/javaguide/csdn/c745c87f6eda9a439e0eea52012c7f4a.png" alt="学生与课程之间联系的E-R图"></p>
<p>实体之间的联系可以是1对1，1对多，或者多对多</p>
<h3 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h3><h4 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h4><p>表中的属性不能再被分割，关系型数据库的最基本要求</p>
<h4 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h4><p>确保数据库表中的每一个属性都和主键有关，<strong>而不是只和联合主键中某一部分相关</strong>。</p>
<h4 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h4><p>确保数据库表中的每一个属性都和主键<strong>直接相关</strong></p>
<h3 id="为什么不使用外键"><a href="#为什么不使用外键" class="headerlink" title="为什么不使用外键"></a>为什么不使用外键</h3><ul>
<li>增加了复杂性：每次做删除和更新操作都必须考虑外键约束</li>
<li>对分库分表不友好：分库分表外键无法生效</li>
</ul>
<h3 id="drop、delete和truncate"><a href="#drop、delete和truncate" class="headerlink" title="drop、delete和truncate"></a>drop、delete和truncate</h3><ul>
<li><code>drop table 表名</code>     直接删除表</li>
<li><code>truncate table 表名</code>   删除表中的数据</li>
<li><code>delete from 表名 where 列名 = 值</code>  删除某一行的数据</li>
</ul>
<p>drop和truncate属于DDL数据定义语言，操作立即生效，delete输入DML数据库操作语言，删除的数据记录会放入回滚段中，等事务提交后才会生效。</p>
<h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><p>非关系型数据库，针对的是键值、文档以及图形类型数据存储。</p>
<p>常见NoSQL数据库：MongoDB和Redis</p>
<h3 id="NoSQL和SQL的区别"><a href="#NoSQL和SQL的区别" class="headerlink" title="NoSQL和SQL的区别"></a>NoSQL和SQL的区别</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240318213400435.png" alt="image-20240318213400435"></p>
<h3 id="NoSQL的优势"><a href="#NoSQL的优势" class="headerlink" title="NoSQL的优势"></a>NoSQL的优势</h3><ul>
<li>灵活性：灵活的架构</li>
<li>可扩展性：通过分布式硬件集群横向拓展</li>
<li>高性能：针对特定的数据模型和访问模式进行了优化，比如Redis基于内存存储，由非常高的读写速度</li>
</ul>
<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>MySQL字符编码中有两套UTF-8编码实现：<code>utf8</code>和<code>utf8mb4</code></p>
<p>UTF8就是Unicode的一种，包含了几乎所有已知的字符。</p>
<p>MySQL中的<code>utf8</code>占1-3个字节，不能很好地表示emoji表情和繁体字，需要用到<code>utf8mb4</code></p>
<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#插入一行</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">USER</span> <span class="keyword">VALUES</span> (<span class="number">10</span>, &quot;root&quot;, &quot;root&quot;); #id, username, password</span><br><span class="line"></span><br><span class="line">#插入一部分</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">USER</span>(id, username) <span class="keyword">VALUES</span>(<span class="number">10</span>, &quot;GUTAO&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> username<span class="operator">=</span><span class="string">&#x27;rebot&#x27;</span> <span class="keyword">WHERE</span> username<span class="operator">=</span><span class="string">&#x27;root&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> username<span class="operator">=</span><span class="string">&#x27;rebot&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#查询表中的所有数据</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span></span><br><span class="line"></span><br><span class="line">#限制查询结果 返回<span class="number">3</span><span class="number">-5</span>行 LIMIT第一个参数偏移量，第二个参数行数</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> LIMIT <span class="number">2</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><code>ORDER BY</code>对单列或者多列进行排序，<code>DESC</code>降序，<code>ASC</code>升序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#先按价格降序，再按名字升序</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price <span class="keyword">DESC</span>, prod_name <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p><code>group by</code>按某个字段进行分组，涉及聚合count、max、sum、avg等操作。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#计算客户名对应的地址数量，然后按客户名分组</span><br><span class="line"><span class="keyword">SELECT</span> cust_name, <span class="built_in">COUNT</span>(cust_address) <span class="keyword">AS</span> addr_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure>

<h3 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h3><p>在<code>where</code>子句中使用，%表示字符出现任意次数，_表示字符出现1次。</p>
<p>这个%类似于*</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;%bean bag%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># MySQL 每页获取十个记录</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_order <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">0</span>, <span class="number">10</span></span><br></pre></td></tr></table></figure>



<h3 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h3><p>MySQL每执行一条语句就把这个语句当成一个事务然后提交</p>
<ul>
<li>START TRANSACTION 开始事务</li>
<li>COMMIT  提交事务</li>
<li>ROLLBACK  回滚，撤销事务，恢复到之前的状态</li>
</ul>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>关系型数据库，常用的还有：SQL Server、Oracle等</p>
<p><strong>优点：成熟稳定、功能完善、开源免费、事务支持优秀</strong></p>
<h2 id="MySQL字段类型"><a href="#MySQL字段类型" class="headerlink" title="MySQL字段类型"></a>MySQL字段类型</h2><p><img src="https://oss.javaguide.cn/github/javaguide/mysql/summary-of-mysql-field-types.png" alt="MySQL 常见字段类型总结"></p>
<h3 id="整型的UNSIGNED"><a href="#整型的UNSIGNED" class="headerlink" title="整型的UNSIGNED"></a>整型的UNSIGNED</h3><p>类似于C++，表示无符号整数</p>
<h3 id="CHAR和VARCHAR"><a href="#CHAR和VARCHAR" class="headerlink" title="CHAR和VARCHAR"></a>CHAR和VARCHAR</h3><p>前者定长，后者不定长，varchar(n)可以设置变长字符串的最大值</p>
<h3 id="VARCHAR-10-和VARCHAR-100"><a href="#VARCHAR-10-和VARCHAR-100" class="headerlink" title="VARCHAR(10)和VARCHAR(100)"></a>VARCHAR(10)和VARCHAR(100)</h3><p>占用磁盘大小相同，但是100会消耗更多的内存来保存值</p>
<h3 id="DECIMAL和FLOAT"><a href="#DECIMAL和FLOAT" class="headerlink" title="DECIMAL和FLOAT"></a>DECIMAL和FLOAT</h3><p>前者是定点数，存储精确的小数值，而float和double只能存近似的小数值。</p>
<h3 id="DATETIME和TIMESTAMP"><a href="#DATETIME和TIMESTAMP" class="headerlink" title="DATETIME和TIMESTAMP"></a>DATETIME和TIMESTAMP</h3><p>前者没有时区信息，占8个字节；后者有时区信息，只占4个字节。</p>
<h3 id="NULL和空"><a href="#NULL和空" class="headerlink" title="NULL和空"></a>NULL和空</h3><p>NULL表示不确定的值，占用空间，两个NULL之间也不一定相等；空就是空，不占用空间。</p>
<p>判断NULL：<code>IS NULL</code> 和 <code>IS NOT NULL</code></p>
<p>因此MySQL不建议用NULL作为默认值。</p>
<h3 id="boolean表示"><a href="#boolean表示" class="headerlink" title="boolean表示"></a>boolean表示</h3><p>TINYINT(1)专门表示</p>
<h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><p>MySQL采用<strong>InnoDB</strong>作为存储引擎，所有的存储引擎只有<strong>InnoDB</strong>是<strong>事务型存储引擎</strong>，支持事务。</p>
<h3 id="存储引擎架构"><a href="#存储引擎架构" class="headerlink" title="存储引擎架构"></a>存储引擎架构</h3><p><strong>插件式架构</strong>，一张表可以对应一个存储引擎</p>
<h3 id="InnoDB和MyISAM"><a href="#InnoDB和MyISAM" class="headerlink" title="InnoDB和MyISAM"></a>InnoDB和MyISAM</h3><p>MySQL5.5之前，用的是MyISAM，5.5之后是InnoDB。</p>
<ul>
<li>MyISAM不支持行级锁，只支持表级锁——&gt;不支持并发查询；</li>
<li>MyISAM不支持事务</li>
<li>MyISAM不支持数据库崩溃后的安全恢复，InnoDB数据库重启会恢复到数据库崩溃前的状态</li>
<li>MyISAM中B+树节点的数据域中存放的是数据记录的地址，还需要根据这个地址读取数据；InnoDB data域存的就是主键的值</li>
</ul>
<h2 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>用于快速查询和检索数据的数据结构</strong>，可以大大加快数据的检索速度。</p>
<h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>哈希表不支持顺序和范围查询</p>
<h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p>非平衡树，最坏的情况下会变成线性链表，查询效率会急剧下降</p>
<h4 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h4><p>自二叉平衡查找树，采用旋转操作保持二叉查找树平衡。</p>
<p>需要频繁地进行旋转操作来保持平衡，每个树节点仅存储一个数据，每次进行磁盘IO只能读取一个节点——&gt;会有频繁的IO操作，耗时</p>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><ol>
<li>根节点总是黑色的</li>
<li>叶子节点（空节点）都是黑色的</li>
<li>节点是红色的，则子节点必须是黑色的</li>
<li>从根节点到叶子节点的路径中黑色节点的数量都是相同的。</li>
</ol>
<p>红黑树并不是严格平衡二叉树，查询效率不如AVL树，但是旋转效率要远远高于AVL树，和AVL树相同的是，红黑树每个节点只能有两个子节点，在磁盘上存储效率不高。</p>
<h4 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h4><ol>
<li>B树所有节点既存放索引，也存放数据；B+树非叶子节点只存放索引，叶子节点存放索引和数据</li>
<li>B树的叶子节点都是独立的；B+树的叶子节点有一条引用链指向与它相邻的叶子节点，所有叶子节点构成一个有序链表</li>
<li>B树进行范围查询，首先要查找下限，然后对其中序遍历，直到找到上限；B+树直接遍历链表。</li>
</ol>
<p>B+树具备更少的IO次数（非叶子节点只存索引），更稳定的查询效率（只搜索叶子节点）和更适用于范围查询。</p>
<h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><h4 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h4><ul>
<li>索引结构和数据一起存放，即InnoDB的B+树的数据域中直接存的是数据</li>
<li>索引结构和数据分开存放，即MyISAM的B+树的数据域中存放的是数据记录的地址——&gt;<strong>二次查询（回表）</strong></li>
</ul>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p><strong>索引包含所有需要查询的字段</strong>，直接从索引中获取数据，不需要访问表的实际数据行。</p>
<p><strong>索引就是帮助你在做查询的时候往索引中的字段去靠，这样能提高查询效率</strong></p>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>使用表中的多个字段创建索引</p>
<p>使用联合索引有个最左前缀匹配原则，会最先根据最左侧的字段过滤一批数据，直至联合索引中的字段全部匹配完成。因此要将区分度高的字段放在联合所以你的最左侧。</p>
<h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><p>这里的索引失效指的是索引没有起到作用</p>
<ul>
<li>创建了联合索引，但查询条件没有遵守最左匹配原则。比如（a, b, c）联合字段，查了b</li>
<li>在索引列上进行计算、函数等操作</li>
<li>以%开头的LIKE查询</li>
</ul>
<h2 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>关系型数据库事务都有ACID特性：原子性、隔离性、持久性——&gt;一致性</p>
<h3 id="并发事务的问题"><a href="#并发事务的问题" class="headerlink" title="并发事务的问题"></a>并发事务的问题</h3><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>一个事务对数据进行了修改，另一个事务读取了这个修改后的数据，然后前一个事务因某种原因回滚，导致第二个事务读到的数据是脏的</p>
<h4 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h4><p>两个事务同时对数据进行修改，则前一个事务对数据的修改丢失了。</p>
<h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>一个事务读取数据，在其第一次读取之后，另外一个事务修改了数据，导致第一个事务两次读到的数据不一致</p>
<h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>一个事务读取了几行数据后，接着另一个事务插入了几行数据，导致第一个事务发现多了一些不存在的数据。            类似于不可重复读</p>
<h3 id="并发事务的控制"><a href="#并发事务的控制" class="headerlink" title="并发事务的控制"></a>并发事务的控制</h3><p>两种方式：锁（悲观），多版本并发控制（MVCC，乐观）</p>
<p>锁分为共享锁和排他锁，共享锁指支持多个事务同时读一个数据，排他锁即写锁，当一个事务对数据进行更新时，其他事务会阻塞。</p>
<p>锁根据粒度不同分为行级锁和表级锁，InnoDB默认是行级锁。</p>
<p>MVCC会对一份数据存储多个版本，实现所依赖的手段：日志undo log(用于记录某行数据的多个版本的数据)</p>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul>
<li>读取未提交</li>
<li>读取已提交</li>
<li>可重复读：指事务执行期间，<strong>其他事务所做的修改对当前事务都不可见</strong>  （MySQL默认隔离级别）</li>
<li>可串行化</li>
</ul>
<p>事务隔离级别都是通过锁和MVCC实现的。</p>
<h2 id="MySQL锁"><a href="#MySQL锁" class="headerlink" title="MySQL锁"></a>MySQL锁</h2><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>行级锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。</p>
<p>若执行UPDATE、DELETE语句时，若WHERE后没有命中索引或者索引失效，InnoDB会对表加锁。</p>
<ul>
<li>记录锁：对单行记录上锁</li>
<li>间隙锁：锁定一段连续的数据范围，不包括记录本身，间隙表示两个相邻数据行之间的区域——为了避免插入新数据</li>
<li>临键锁：锁定一个范围，包括记录本身  （默认行级锁）</li>
</ul>
<h3 id="sql优化手段"><a href="#sql优化手段" class="headerlink" title="sql优化手段"></a>sql优化手段</h3><ul>
<li>避免使用SELECT * 语句    消耗CPU、无法使用覆盖索引的优化</li>
<li>避免使用外键或级联操作    对分库分表不友好</li>
<li>选用合适的字段类型           存储字节越小，占用空间越小，性能也越好</li>
</ul>
<h2 id="MySQL三大日志"><a href="#MySQL三大日志" class="headerlink" title="MySQL三大日志"></a>MySQL三大日志</h2><p>归档日志<code>binlog</code>  同步数据，保证数据一致性</p>
<p>重做日志redo log  让InnoDB有了崩溃恢复能力									  <strong>持久性</strong></p>
<p>回滚日志undo log  记录事务对于数据的修改，可以对已进行的操作进行回滚                         原子性</p>
<h2 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h2><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>一台服务器负责写，多台服务器负责读，主库和从库之间进行数据同步。</p>
<p>实现：在请求和数据库之间设置代理，将不同的请求路由到不同库</p>
<p>一看到<strong>数据同步</strong>、<strong>主从复制</strong>就要想到binlog</p>
<p>如何避免主从延迟？在更新之后直接到主库读取或者延迟读取</p>
<h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><h4 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h4><ul>
<li>垂直分库：把单一数据库按业务划分，分成不同的数据库，简单理解就是把全部字段分布到多个数据库中</li>
<li>水平分库：相同的表，因为数据量过大分到多个数据库中存储</li>
</ul>
<h4 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h4><ul>
<li>垂直分表：一张表列太多，分成多张表</li>
<li>水平分表：和水平分库一样</li>
</ul>
<h4 id="分库分表带来的问题"><a href="#分库分表带来的问题" class="headerlink" title="分库分表带来的问题"></a>分库分表带来的问题</h4><ul>
<li>事务问题</li>
<li>跨库聚合查询问题</li>
</ul>
<h3 id="冷热分离"><a href="#冷热分离" class="headerlink" title="冷热分离"></a>冷热分离</h3><p>冷热表示根据数据的访问频率和业务重要性对数据进行分类。</p>
<p>冷数据存在低成本低性能的存储介质中，热数据存在高成本高性能介质中。</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>基于C语言开发的NoSQL数据库</p>
<h3 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h3><ul>
<li>基于内存，关系型数据库一般基于硬盘</li>
<li>内置了多种优化过后的数据结构，性能高</li>
</ul>
<p>相比于MySQL，Redis高性能且高并发</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>分布式锁     基于Redisson实现分布式锁</li>
<li>限流            Redis+Lua脚本实现限流</li>
<li>分布式Session       利用String或Hash保存Session数据</li>
<li>搜索引擎         借助RediSearch</li>
</ul>
<h3 id="5种基本数据类型"><a href="#5种基本数据类型" class="headerlink" title="5种基本数据类型"></a>5种基本数据类型</h3><p>String         List               Set          Hash         Zset</p>
<h4 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h4><p>存储字符串、数、图片、序列后的对象</p>
<h5 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h5><p><strong>简单动态字符串SDS</strong></p>
<ul>
<li>可以避免缓冲区溢出</li>
<li>获取字符串长度复杂度O(1)</li>
</ul>
<h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><ul>
<li>SET key value        设置key的值</li>
<li>SETNX key value    key不存在时设置key的值</li>
<li>EXPIRE key seconds   给key设置过期时间</li>
<li>INCR key                 自增1</li>
<li>DECR key                自减1</li>
</ul>
<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>访问次数       利用自增命令</p>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><ul>
<li>HSET key field value</li>
</ul>
<p>存储含有多个字段的对象的信息</p>
<p><strong>购物车中商品频繁修改和变动，用商品id为field，商品数量为value</strong></p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><h5 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h5><ul>
<li>SADD key member1 member2   向集合添加多个元素</li>
<li>SINTER key1 key2                          求交集</li>
<li>SUNION key1 key2                        求并集</li>
<li>SDIFF key1 key2                             求差集</li>
<li>SPOP key count                              随机移除count个元素</li>
<li>SRANDMEMBER key count           随机获取count个元素</li>
</ul>
<h5 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h5><ol>
<li>点赞统计         利用set集合的特性</li>
<li>共同好友（交集）、好友推荐（差集）</li>
<li>抽奖，随机点名   随机获取1个数</li>
</ol>
<h4 id="Sorted-Set-——-Zset"><a href="#Sorted-Set-——-Zset" class="headerlink" title="Sorted Set   ——  Zset"></a>Sorted Set   ——  Zset</h4><p>在SET的基础上增加了一个权重参数score，使元素能够按score排序。</p>
<h5 id="底层实现-1"><a href="#底层实现-1" class="headerlink" title="底层实现"></a>底层实现</h5><p><strong>跳跃表</strong>       概率平衡</p>
<p>为什么不用平衡树、红黑树？跳表不需要像平衡树通过旋转保持平衡，不需要像红黑树通过旋转、染色来保证黑平衡。这两个树区间查找也没有跳表效率高。</p>
<h5 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h5><ul>
<li>ZADD key score1 member1 score2 member2</li>
<li>ZINTERSTORE destination numkeys key1 key2   求交集，相同member的score会相加</li>
<li>ZUNIONSTORE destination numkeys key1 key2 求并集</li>
<li>ZDIFFSTORE destination numkeys key1 key2      求差集</li>
<li>ZRANGE key start end     获取score从低到高的元素</li>
<li>ZREVRANGE key start end  获取score从高到低的元素</li>
<li>ZREVRANK key member       获取元素的排名</li>
</ul>
<h5 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h5><p>排行榜，优先级任务队列</p>
<h3 id="3种特殊数据类型"><a href="#3种特殊数据类型" class="headerlink" title="3种特殊数据类型"></a>3种特殊数据类型</h3><h4 id="Bitmap位图"><a href="#Bitmap位图" class="headerlink" title="Bitmap位图"></a>Bitmap位图</h4><p>存储连续的二进制数字，1bit表示一位，从左到右分别为offset0  offset1  offset2</p>
<h5 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h5><ul>
<li>SETBIT key offset value        设置指定offset位置的值</li>
<li>BITCOUNT key start end      计算[start, end]区间内1的个数</li>
</ul>
<h5 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h5><p>用户签到情况</p>
<h4 id="HyperLogLog基数统计"><a href="#HyperLogLog基数统计" class="headerlink" title="HyperLogLog基数统计"></a>HyperLogLog基数统计</h4><p>估计集合中不同元素的个数</p>
<p>两种方式计数：</p>
<ul>
<li>稀疏矩阵：计数较少，占用空间小</li>
<li>稠密矩阵：计数到阈值，占用12K的空间</li>
</ul>
<h5 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h5><ul>
<li>PFADD key element1      添加元素</li>
<li>PFCOUNT key1 key2       统计一个或多个集合的计数</li>
<li>PFMEAGE destkey key1 key2  合并多个集合到一个集合中</li>
</ul>
<h5 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h5><p>数据量巨大的计数场景</p>
<h4 id="Geospatial地理位置"><a href="#Geospatial地理位置" class="headerlink" title="Geospatial地理位置"></a>Geospatial地理位置</h4><p>底层为Zset实现，存储地理位置信息</p>
<h5 id="常用命令-5"><a href="#常用命令-5" class="headerlink" title="常用命令"></a>常用命令</h5><ul>
<li>GEODIST key member1 member2 M&#x2F;KM      计算两个经纬度之间的距离</li>
<li>GEOADD key longitude1 latitude1 member1  添加经纬度</li>
</ul>
<h5 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h5><p>计算附近的人   通过计算两个经纬度之间的距离，判断是否是附近的人</p>
<h3 id="Redis持久化机制"><a href="#Redis持久化机制" class="headerlink" title="Redis持久化机制"></a>Redis持久化机制</h3><p>三种持久化方式：</p>
<ul>
<li>快照RDB</li>
<li>只追加文件AOF</li>
<li>RDB和AOF混合持久化</li>
</ul>
<h4 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h4><p>创建快照获得存储在内存中的数据在某个时间点的副本</p>
<h5 id="RDB生成快照的方式"><a href="#RDB生成快照的方式" class="headerlink" title="RDB生成快照的方式"></a>RDB生成快照的方式</h5><ul>
<li>save：同步保存操作，会阻塞Redis主线程</li>
<li>bgsave：fork（系统调用创建子进程），子进程执行。  默认方式</li>
</ul>
<h4 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h4><p>每执行一条更新数据的命令，Redis将命令写入到AOF缓冲区中，再写到AOF文件中，最后再根据持久化方式决定何时将缓存中的数据同步到硬盘中。</p>
<h5 id="AOF持久化方式"><a href="#AOF持久化方式" class="headerlink" title="AOF持久化方式"></a>AOF持久化方式</h5><ul>
<li>always：主线程write写后，后台立即会调用fsync函数同步</li>
<li>everysec：每秒钟同步一次</li>
<li>no：让操作系统决定多久同步一次，Linux是30s</li>
</ul>
<h5 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h5><p>当AOF文件变得很大时，Redis会在后台子进程重写一个AOF文件，这个AOF文件和原文件数据库状态一样，但体积更小。</p>
<h4 id="RDB和AOF"><a href="#RDB和AOF" class="headerlink" title="RDB和AOF"></a>RDB和AOF</h4><p>RDB</p>
<ul>
<li>高性能，通过fork子进程完成持久化；RDB文件在指定的时间间隔内生成，而且是经过压缩的二进制数据，便于备份与恢复。</li>
<li>Redis发生故障会丢失最近的一次快照；持久化是周期性的，不能保证每个操作都持久化到磁盘，不适用于实时持久化</li>
</ul>
<p>AOF</p>
<ul>
<li>AOF持久化记录了每个操作命令，可以确保Redis数据的完整性，即使发生故障也能恢复；几乎是实时记录每个写操作，适用于实时持久化</li>
<li>AOF文件比RDB大很多，重写也会消耗资源；恢复数据需要依次执行每个写命令，速度非常慢。</li>
</ul>
<h3 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h3><h4 id="Redis单线程模型"><a href="#Redis单线程模型" class="headerlink" title="Redis单线程模型"></a>Redis单线程模型</h4><p>读写命令是单线程，但通过<strong>非阻塞IO多路复用程序</strong>来监听多个套接字，通过单线程处理多个客户端的请求，减少了线程切换和同步开销。</p>
<p>基于Reactor模式（核心就是非阻塞IO）设计了文件事件处理器，非阻塞IO多路复用程序和多个客户端都是这个处理器的一部分。</p>
<p><strong>为什么Redis不用多线程？</strong>单线程更容易维护；Redis的瓶颈在于内存和网络，而不是CPU</p>
<h4 id="Redis多线程"><a href="#Redis多线程" class="headerlink" title="Redis多线程"></a>Redis多线程</h4><p>主要为了提高网络IO读写性能，多线程只运用于网络数据的读写，执行命令还是单线程。</p>
<h4 id="Redis后台线程"><a href="#Redis后台线程" class="headerlink" title="Redis后台线程"></a>Redis后台线程</h4><ul>
<li><p>bio_close_file：释放RDB和AOF的临时问那件资源</p>
</li>
<li><p>bio_fsync：将AOF缓冲区的内容写入到AOF文件</p>
</li>
</ul>
<h3 id="Redis内存管理"><a href="#Redis内存管理" class="headerlink" title="Redis内存管理"></a>Redis内存管理</h3><h4 id="为数据设置过期时间"><a href="#为数据设置过期时间" class="headerlink" title="为数据设置过期时间"></a>为数据设置过期时间</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数据在60s后过期</span></span><br><span class="line">expire key 60</span><br><span class="line"></span><br><span class="line"><span class="comment">#键值在60s后过期</span></span><br><span class="line">setex key 60 value</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看过期时间</span></span><br><span class="line">ttl key</span><br></pre></td></tr></table></figure>

<p>因为Redis会将数据放在内存中，不设置过期时间，所有数据都一直保存的话，内存会爆；</p>
<p>应用于验证码，网页的限期token</p>
<h4 id="Redis怎么判断过期"><a href="#Redis怎么判断过期" class="headerlink" title="Redis怎么判断过期"></a>Redis怎么判断过期</h4><p>通过过期字典保存数据过期的时间，过期字典的键指向Redis中的某个键</p>
<h4 id="过期数据的删除策略"><a href="#过期数据的删除策略" class="headerlink" title="过期数据的删除策略"></a>过期数据的删除策略</h4><ul>
<li>惰性删除：在取key值的时候检查是否过期，对CPU比较友好</li>
<li>定期删除：每隔一段时间执行删除过期的key，对内存比较友好</li>
</ul>
<h4 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h4><ul>
<li>volatile-lru </li>
<li>volatile-ttl 选择要过期的数据淘汰</li>
<li>allkeys-lru 内存不足，</li>
<li>random  任意选择淘汰</li>
</ul>
<h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h3><p>和关系型数据库不一样，它是将多个命令打包，再按顺序执行命令，不会被打断。</p>
<p>Redis事务不满足原子性，执行过程中命令出现错误，其他命令都能正常执行。</p>
<p>Redis事务也不满足持久性，Redis本身具有持久性，由持久化机制实现。</p>
<h3 id="Redis性能优化"><a href="#Redis性能优化" class="headerlink" title="Redis性能优化"></a>Redis性能优化</h3><h4 id="批量操作减少网络传输"><a href="#批量操作减少网络传输" class="headerlink" title="批量操作减少网络传输"></a>批量操作减少网络传输</h4><p>Redis事务会将每个命令都发送到服务端，网络开销太大。因此要批量操作减少IO次数。</p>
<ul>
<li>原生批量操作    比如MSET，SADD</li>
<li>pipeline流水线  </li>
<li>Lua脚本  一段Lua脚本被视为一条命令操作，在执行过程中不会有其他命令同时执行，但是出错后也不可以回滚</li>
</ul>
<p>这三种方式都无法保证所有的key在同一个哈希槽上，因为Redis的分片机制。</p>
<h4 id="大量key集中过期"><a href="#大量key集中过期" class="headerlink" title="大量key集中过期"></a>大量key集中过期</h4><p>采用定期删除+惰性删除的策略。</p>
<p>定期删除有一个问题，它会阻塞Redis主线程，若有大量过期key，则响应速度会变慢。</p>
<p>解决方法：key设置随机过期时间；采用lazy-free，采用异步方式释放过期的key，不会阻塞主线程</p>
<h4 id="bigkey-大Key"><a href="#bigkey-大Key" class="headerlink" title="bigkey  大Key"></a>bigkey  大Key</h4><p>出现的原因：</p>
<ul>
<li>string类型写入太多二进制数据</li>
<li>复合类型中存了太多条数据</li>
</ul>
<p>解决方案：</p>
<ul>
<li>对于大量字段的Hash，可以二次哈希拆分为多个Hash</li>
<li>lazy-free</li>
</ul>
<h4 id="hotkey-热key"><a href="#hotkey-热key" class="headerlink" title="hotkey 热key"></a>hotkey 热key</h4><p>某个热点数据访问量暴增，有可能会超出Redis的处理能力，导致Redis崩溃</p>
<p>发现hotkey：</p>
<ul>
<li>–hotkeys参数</li>
<li>公有云Redis分析</li>
</ul>
<p>解决方案：</p>
<ul>
<li>读写分离：主节点处理写请求，从节点处理读请求</li>
<li>Redis Cluster：热点数据分散存储在多个Redis节点上</li>
</ul>
<h4 id="慢查询指令"><a href="#慢查询指令" class="headerlink" title="慢查询指令"></a>慢查询指令</h4><p>Redis中的某些操作指令的时间复杂度是O(n)，如果有大量数据记录，则这些指令执行会很慢</p>
<h3 id="Redis高可用的做法"><a href="#Redis高可用的做法" class="headerlink" title="Redis高可用的做法"></a>Redis高可用的做法</h3><p>高可用是指系统在面对各种故障情况下，保持长时间的可用性和稳定性。</p>
<ul>
<li>主从复制：redis集群中分为主节点和从节点，主从复制是指将一个 Redis 服务器（主节点）的数据复制到其他 Redis 服务器（从节点）上。主从复制提供了数据冗余备份、读写分离以及故障恢复等功能。</li>
<li>哨兵机制：主要用于监控 Redis 主从服务器的运行状态，自动完成故障转移。当哨兵发现主节点失效时，它会在哨兵系统中发起选举，选出一个哨兵作为领导者来执行自动故障转移的操作。</li>
<li>持久化：ROB和AOF方式实现持久化</li>
</ul>
<h3 id="Redis内存碎片"><a href="#Redis内存碎片" class="headerlink" title="Redis内存碎片"></a>Redis内存碎片</h3><ul>
<li>Redis存储数据向操作系统申请的内存空间可能会大于数据实际所需要的内存空间</li>
<li>频繁修改Redis中的数据（Redis通常不会轻易释放内存给操作系统）</li>
</ul>
<h3 id="Redis生产问题"><a href="#Redis生产问题" class="headerlink" title="Redis生产问题"></a>Redis生产问题</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>请求的key既不在缓存中，也不在数据库中。如果有大量这种请求，数据库压力会特别大，甚至会宕机。</p>
<p>真实场景：黑客故意制造大量的非法key发起请求</p>
<p>解决方法：</p>
<p>最基本的做好参数校验</p>
<ul>
<li>缓存无效key：来一个无效key请求就在Redis中缓存一个key，这样只能应付key变化不明显的情况</li>
<li>布隆过滤器：较大的bit数组，一个元素只占1bit，用0或1表示，把所有可能存在请求的值存放在布隆过滤器中，当用户发来的请求的值不在布隆过滤器中，直接返回请求参数错误回客户端</li>
<li>根据IP进行限流</li>
</ul>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>请求的key是hotkey，但是它在Redis中过期了，导致大量请求访问数据库</p>
<p>真实场景：秒杀系统</p>
<p>解决方法：</p>
<ul>
<li>设置热点数据永不过期</li>
<li>针对热点数据提前预热，比如在秒杀场景中设置秒杀结束之前都不过期</li>
</ul>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>Redis中大量的key同时过期或者Redis崩溃，导致大量的请求全都访问数据库。</p>
<p>解决方案：</p>
<ul>
<li><p>防止Redis崩溃：</p>
<ul>
<li>采用Redis集群</li>
<li>限流</li>
</ul>
</li>
<li><p>热点缓存失效  参考缓存击穿</p>
</li>
</ul>
<h3 id="Redis和数据库的双写一致性"><a href="#Redis和数据库的双写一致性" class="headerlink" title="Redis和数据库的双写一致性"></a>Redis和数据库的双写一致性</h3><p>先更新数据库，再删除缓存。</p>
<p>如果更新数据库成功，但是删除缓存失败，可以增加cache更新重试机制</p>
<h3 id="Redis常见阻塞原因"><a href="#Redis常见阻塞原因" class="headerlink" title="Redis常见阻塞原因"></a>Redis常见阻塞原因</h3><ol>
<li>慢查询命令</li>
<li>调用save而非bgsave创建RDB快照</li>
<li>不合理的AOF持久化方式</li>
<li>AOF重写阻塞</li>
<li>bigkey</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jiangduwang.github.io/2024/06/03/%E6%95%B0%E6%8D%AE%E5%BA%93/" data-id="clwyjx9fj0003jkul23kceoyx" data-title="数据库八股" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/03/Java/" class="article-date">
  <time class="dt-published" datetime="2024-06-03T05:49:25.228Z" itemprop="datePublished">2024-06-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/06/03/Java/">java八股</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><blockquote>
<p>3.4</p>
</blockquote>
<h3 id="基础概念与常识"><a href="#基础概念与常识" class="headerlink" title="基础概念与常识"></a>基础概念与常识</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>面向对象（封装、继承、多态）</li>
<li>编译与解释并存——javac编译.java，JVM解释.class</li>
<li>平台无关性（Java虚拟机）</li>
</ul>
<h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><p>运行Java字节码(.class文件)的虚拟机，针对不同的系统有不同的JVM实现，目的是生成相同的字节码——平台无关性</p>
<p>最常用——HotSpot VM</p>
<h4 id="JDK和JRE"><a href="#JDK和JRE" class="headerlink" title="JDK和JRE"></a>JDK和JRE</h4><p>JDK(java development kit)    Java SDK   包含javac、jre等</p>
<p>JRE(java runtime environment)  运行已编译java程序所需的所有资源，包含JVM和Java类库</p>
<h4 id="Java程序从源代码到可执行程序"><a href="#Java程序从源代码到可执行程序" class="headerlink" title="Java程序从源代码到可执行程序"></a>Java程序从源代码到可执行程序</h4><p>源代码.java文件，经过javac编译器生成字节码.class文件，再经过JVM中的解释器生成机器码。</p>
<p>纯解释器效率太慢，引入了JIT编译器，对于经常会调用或者比较消耗系统资源的方法或者代码块交给JIT<strong>运行时编译</strong>，第一次编译后，会保存对应的机器码，下次直接使用。</p>
<p>编译——C C++ go</p>
<p>解释——python js PHP</p>
<h4 id="AOT"><a href="#AOT" class="headerlink" title="AOT"></a>AOT</h4><p>Java9引入的编译模式，和JIT不同的是，它是静态编译，在程序被执行前就将其编译成机器码。</p>
<p>适用于云原生场景，微服务架构</p>
<p>AOT优势在于启动时间、内存占用和打包体积，缺点在于不支持java的动态特性，如反射、动态代理。</p>
<h4 id="C-和Java"><a href="#C-和Java" class="headerlink" title="C++和Java"></a>C++和Java</h4><ul>
<li>Java不提供指针直接访问内存，程序内存更加安全，不容易出现内存泄漏</li>
<li>Java类只能单继承，C++支持多继承， Java接口支持多继承</li>
<li>Java有自动内存管理垃圾回收机制，不需要像C++手动释放内存</li>
</ul>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>1字节（byte） &#x3D;  8bit  -128-127  补码表示</p>
<p>short2字节，int4字节，long8字节，char2字节，float4字节，double8字节，boolean1位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20L</span>;</span><br></pre></td></tr></table></figure>

<h4 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h4><p>包装类型属于对象类型，集合类中的泛型只能使用包装类型</p>
<ul>
<li><strong>存储方式</strong>：基本类型的局部变量和对象引用存放在Java虚拟机的栈中，未被static修饰的成员变量和对象实例存放在Java虚拟机的堆中</li>
<li><strong>默认值</strong>：包装类型默认值为null</li>
<li><strong>比较方式</strong>：基本类型的比较方式：&#x3D;&#x3D;        包装类型的比较方式：equals            对于包装类型， &#x3D;&#x3D; 比较的是对象的内存地址</li>
</ul>
<h4 id="包装类型的缓存机制"><a href="#包装类型的缓存机制" class="headerlink" title="包装类型的缓存机制"></a>包装类型的缓存机制</h4><p>四个表示整型的包装类型均创建了[-128, 127]的缓存数据区域，Character为[0, 127]           浮点型包装类型无缓存机制</p>
<p>直接通过自动装箱创建的包装类型，如果在缓存数据区域，则会直接从缓存中取。</p>
<h4 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h4><p>下面这两行是等同的，第一行代码实现了自动装箱</p>
<p>自动装箱的本质就是调用valueOf函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h4 id="解决浮点数运算的精度丢失问题"><a href="#解决浮点数运算的精度丢失问题" class="headerlink" title="解决浮点数运算的精度丢失问题"></a>解决浮点数运算的精度丢失问题</h4><p><strong>BigDecimal</strong>实现对浮点数的运算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8732&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">System.out.println(a.add(b));<span class="comment">// 1.9 加</span></span><br><span class="line">System.out.println(a.subtract(b));<span class="comment">// 0.1 减</span></span><br><span class="line">System.out.println(a.multiply(b));<span class="comment">// 0.90 乘</span></span><br><span class="line">System.out.println(a.divide(b));<span class="comment">// 无法除尽，抛出 ArithmeticException 异常</span></span><br><span class="line">System.out.println(a.divide(b, <span class="number">2</span>, RoundingMode.HALF_UP));<span class="comment">// 1.11  第二个参数保留几位 第三个参数保留规则</span></span><br><span class="line">System.out.println(a.compareTo(b));  <span class="comment">//比较大小</span></span><br><span class="line">System.out.println(a.equals(b));   <span class="comment">//等值比较</span></span><br></pre></td></tr></table></figure>



<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>成员变量会自动赋默认值，局部变量则不会</p>
<p>静态变量属于类，为所有的对象实例共享，只会被分配一次内存，一般用final关键字修饰</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员"></a>静态方法为什么不能调用非静态成员</h4><p>静态方法在类加载时就会分配内存，而非静态成员必须在对象实例化后才能存在。</p>
<h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>方法名相同，返回类型、参数类型、参数个数、参数顺序都可以不同。</p>
<p>最典型的例子——类的构造函数，可以有多个</p>
<h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>子类对父类允许访问的方法进行重写，方法名、参数列表必须相同</p>
<p>当子类强转为父类时，调用的还是父类的方法</p>
<h4 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h4><p>可变长参数前可以有其他参数，后面不行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(String... args)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(String args1, String... args)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h3><h4 id="三大特征"><a href="#三大特征" class="headerlink" title="三大特征"></a>三大特征</h4><ul>
<li>封装——修饰符private限制访问</li>
<li>继承</li>
<li>多态——重载与重写</li>
</ul>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>一个类可以实现多个接口，实现接口必须要实现接口中的所有方法，接口中的成员变量只能是<strong>public static final</strong>类型的，不能被修改且有初始值</p>
<h4 id="深拷贝、浅拷贝与引用拷贝"><a href="#深拷贝、浅拷贝与引用拷贝" class="headerlink" title="深拷贝、浅拷贝与引用拷贝"></a>深拷贝、浅拷贝与引用拷贝</h4><ul>
<li>引用拷贝：创建一个新的引用指向原对象所在的内存，本质上还是同一个对象</li>
<li>浅拷贝：会在堆上创建一个新的对象，如果类中有引用型的成员变量，这个成员变量会引用拷贝</li>
<li>深拷贝：创建一个和原对象一模一样的对象，但是存储所在的内存空间不同</li>
</ul>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><p>对于基本数据类型，&#x3D;&#x3D;是比较他们的值是否相同，而引用类型则为比较他们的内存地址是否相同</p>
<p>Object的equals也是比较两个对象的内存地址，String中的equals重写过了，因此是直接比较两个字符串中的值</p>
<h4 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h4><p>获取对象在哈希表中的索引位置，主要还是用于判断两个对象是否相等——&gt;提高判断是否不存在的效率</p>
<p>两个对象的hashCode不相等——&gt;肯定不相等</p>
<p>两个对象的hashCode相等——&gt;可能不相等，由于哈希冲突</p>
<p><strong>重写equals方法时必须要重写hashCode方法，避免hashCode不相等而equals相等的情况</strong></p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="String是不可变的"><a href="#String是不可变的" class="headerlink" title="String是不可变的"></a>String是不可变的</h4><p>用<strong>private final</strong>修饰的字符数组，且没有提供修改字符数组的接口；String类有final关键字修饰，不可被继承。</p>
<h4 id="StringBuilder和StringBuffer"><a href="#StringBuilder和StringBuffer" class="headerlink" title="StringBuilder和StringBuffer"></a>StringBuilder和StringBuffer</h4><p>StringBuffer对方法加了同步锁，线程安全；StringBuilder线程不安全</p>
<p><strong>所谓线程安不安全，主要是是否有synchronized关键字修饰</strong></p>
<h4 id="append和"><a href="#append和" class="headerlink" title="append和+"></a>append和+</h4><p>字符串的拼接有两种方式，将字符串实例化为StringBuilder对象，然后调用append方法拼接字符串，这种方式是在自身进行操作，不会生成新的对象；</p>
<p>在Java9之前，+直接拼接String字符串实际上也是调用append方法，但是会生成多个StringBuilder对象，在Java9之后，这个问题已经解决了。</p>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>类似于包装类型的缓存区域，String也有一个缓存区域，避免字符串对象的重复创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>若常量池中没有abc这个字符串，就会生成两个对象，一个在常量池中，一个在堆上。</p>
<h4 id="String-intern"><a href="#String-intern" class="headerlink" title="String#intern"></a>String#intern</h4><p>字符串对象调用intern方法，直接获得这个字符串在常量池中的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”Java“</span></span><br><span class="line"><span class="comment">// 将字符串对象”Java“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="comment">// 会在堆中在单独创建一个字符串对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s3.intern();</span><br><span class="line"><span class="comment">// s1 和 s2 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// s3 和 s4 指向的是堆中不同的对象</span></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// s1 和 s4 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s4); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="的进一步深化"><a href="#的进一步深化" class="headerlink" title="+的进一步深化"></a>+的进一步深化</h4><p>常量折叠：javac会把常量表达式的值求出来嵌入变量中。（当变量以final关键字修饰，也算常量）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="comment">//常量折叠 相当于String str3 = &quot;string&quot;;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2;</span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>3.5</p>
</blockquote>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>Java中所有的异常均继承于Throwable类，分为Exception和Error两种</p>
<h4 id="Throwable的常用方法"><a href="#Throwable的常用方法" class="headerlink" title="Throwable的常用方法"></a>Throwable的常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getMessage</span><span class="params">()</span>  <span class="comment">//异常简要描述</span></span><br><span class="line">String <span class="title function_">toString</span><span class="params">()</span>    <span class="comment">//异常详细信息</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printStackTrace</span><span class="params">()</span> <span class="comment">//打印异常信息</span></span><br></pre></td></tr></table></figure>

<h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><p>finally中的内容几乎一定会执行，若try或catch中有return，则finally也会先执行再return。</p>
<p>try和finally中同时有return时，finally的return会覆盖try</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型类、泛型接口、泛型方法</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>在运行时可以分析类以及执行类中的方法，通过反射可以获取类的所有属性和方法。</p>
<p>反射让代码更加灵活，广泛应用于各种Java框架，包括动态代理，但是性能会差点。</p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这两种定义都是可以的</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="解析方法"><a href="#解析方法" class="headerlink" title="解析方法"></a>解析方法</h4><ul>
<li><p>编译期直接扫描，比如@Override</p>
</li>
<li><p>运行时通过<strong>反射</strong>处理，比如@Value和@Component</p>
</li>
</ul>
<h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><p>service provider interface   跟api完全相反，接口在调用方，让实现方适配接口。</p>
<p>Spring、数据库加载驱动都使用了SPI机制</p>
<p>典型例子：SLF4J</p>
<h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><p>序列化就是将数据结构或对象转换为二进制字节流的过程，反序列化就是序列化的逆过程。</p>
<p>序列化的目的就是便于网络传输或者存入内存或数据库中。</p>
<p>TCP&#x2F;IP四层模型：应用层、传输层、网络层、网络接口层</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-ip-4-model.png" alt="TCP/IP 四层模型"></p>
<p>序列化在OSI七层模型的表示层，因此属于应用层。</p>
<p>序列化协议：Protobuf</p>
<h3 id="I-O"><a href="#I-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h3><p>I&#x2F;O流分为字节流与字符流</p>
<ul>
<li>InputStream   OutputStream</li>
<li>Reader   Writer</li>
</ul>
<h4 id="分为字节流与字符流的原因"><a href="#分为字节流与字符流的原因" class="headerlink" title="分为字节流与字符流的原因"></a>分为字节流与字符流的原因</h4><p>字节流转为字符流比较耗时，而且不指定编码类型的话，字节流容易乱码。</p>
<h4 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h4><p>字节缓冲流会先将读取到的字节存放在缓冲区，大幅减少IO的次数，提高读写效率。</p>
<h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><p>方便程序员开发设计的语法，可以更简洁的实现功能。</p>
<p>JVM并不能识别语法糖，是通过javac编译器解糖。</p>
<p>常见的语法糖：For each遍历、泛型、自动装拆箱、变长参数、lambda表达式、switch对String的支持</p>
<h3 id="重要知识点"><a href="#重要知识点" class="headerlink" title="重要知识点"></a>重要知识点</h3><h4 id="Java值传递"><a href="#Java值传递" class="headerlink" title="Java值传递"></a>Java值传递</h4><p><strong>首先Java中只有值传递，并没有引用传递。</strong></p>
<p>对于普通数据类型，若在函数中修改值，则不会修改成功，因为实参的值是通过形参传递过去，成功修改了形参的值，但是没有修改原来实参的值。</p>
<p>对于对象数据类型，是可以修改成功的，但是和C++不一样的是，C++中的引用即别名，引用和原来实参共用了同一个内存空间，因此修改引用也可以修改原来的实参，Java中实际上将实参的地址值作为形参传递过去了，因此可以对原来的实参进行修改。</p>
<p>C++中的引用和原实参是相同的一片内存空间，Java对象类型是形参和实参都指向了同一地址，但是两个参数还是不同的。</p>
<p>简单点说，就是Java的值传递会创建一个新副本，有别于原来的实参。</p>
<h4 id="Java序列化"><a href="#Java序列化" class="headerlink" title="Java序列化"></a>Java序列化</h4><h5 id="JDK自带的序列化方式"><a href="#JDK自带的序列化方式" class="headerlink" title="JDK自带的序列化方式"></a>JDK自带的序列化方式</h5><p>需要实现<strong>Serializable</strong>接口，表明这个类可以序列化和反序列化</p>
<h4 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h4><h5 id="获取Class对象的四种方式"><a href="#获取Class对象的四种方式" class="headerlink" title="获取Class对象的四种方式"></a>获取Class对象的四种方式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass</span> <span class="operator">=</span> TargetObject.class;</span><br><span class="line"></span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">TargetObject</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TargetObject</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass2</span> <span class="operator">=</span> o.getClass();</span><br><span class="line"></span><br><span class="line">ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="反射的基本操作"><a href="#反射的基本操作" class="headerlink" title="反射的基本操作"></a>反射的基本操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javaguide;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetObject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TargetObject</span><span class="params">()</span> &#123;</span><br><span class="line">        value = <span class="string">&quot;JavaGuide&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publicMethod</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I love &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">privateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;value is &quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.javaguide;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取 TargetObject 类的 Class 对象并且创建 TargetObject 类实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;?&gt; targetClass = Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br><span class="line">        <span class="type">TargetObject</span> <span class="variable">targetObject</span> <span class="operator">=</span> (TargetObject) targetClass.newInstance();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取 TargetObject 类中定义的所有方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Method[] methods = targetClass.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取指定方法并调用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">publicMethod</span> <span class="operator">=</span> targetClass.getDeclaredMethod(<span class="string">&quot;publicMethod&quot;</span>,</span><br><span class="line">                String.class);</span><br><span class="line"></span><br><span class="line">        publicMethod.invoke(targetObject, <span class="string">&quot;JavaGuide&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取指定参数并对参数进行修改</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> targetClass.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="comment">//为了对类中的参数进行修改我们取消安全检查</span></span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(targetObject, <span class="string">&quot;JavaGuide&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用 private 方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">privateMethod</span> <span class="operator">=</span> targetClass.getDeclaredMethod(<span class="string">&quot;privateMethod&quot;</span>);</span><br><span class="line">        <span class="comment">//为了调用private方法我们取消安全检查</span></span><br><span class="line">        privateMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        privateMethod.invoke(targetObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Java代理模式"><a href="#Java代理模式" class="headerlink" title="Java代理模式"></a>Java代理模式</h4><p>使用代理对象代替真实对象的访问，在不修改原对象的前提下，添加增强操作——&gt;有点像AOP?</p>
<h5 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h5><p>定义一个接口，定义一个真实类实现接口，再定义一个代理类也实现接口，在实际使用中，将真实类的目标对象注入到代理类中。</p>
<h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><p>AOP和RPC都使用了动态代理，重点看一下JDK动态代理</p>
<p>Proxy#newProxyInstance()生成代理对象</p>
<p>创建一个类实现**<code>InvocationHandler</code>**接口，主要是实现invoke方法，invoke方法中需要传入代理对象、增强的方法对象以及方法的参数，在这个invoke方法中同样会调用method.invoke()通过反射执行方法。</p>
<ul>
<li>接口类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    String <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现接口类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>动态代理类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DebugInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取代理对象类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(), <span class="comment">// 目标类的类加载器</span></span><br><span class="line">                target.getClass().getInterfaces(),  <span class="comment">// 代理需要实现的接口，可指定多个</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DebugInvocationHandler</span>(target)   <span class="comment">// 代理对象对应的自定义 InvocationHandler</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实际使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> (SmsService) JdkProxyFactory.getProxy(<span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>());</span><br><span class="line">smsService.send(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>JDK动态代理只能代理实现了接口的类或者直接代理接口，CGLIB可以代理未实现任何接口的类，它是通过生成一个被代理类的子类来拦截被代理类的方法调用。</p>
<h4 id="Java魔法类Unsafe"><a href="#Java魔法类Unsafe" class="headerlink" title="Java魔法类Unsafe"></a>Java魔法类Unsafe</h4><p>执行一些跟系统资源相关的操作，跟C++差不多，主要就是让Java拥有操作内存的能力。</p>
<p>native关键字修饰本地方法——Java中用其他变成语言编写的方法。</p>
<ul>
<li>内存操作</li>
<li>线程调度</li>
<li>系统信息</li>
</ul>
<blockquote>
<p>3.6</p>
</blockquote>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>Java集合分为两个接口：<strong>Collection</strong>和<strong>Map</strong>，<strong>Collection</strong>包括<strong>List</strong>、<strong>Set</strong>和<strong>Queue</strong></p>
<ul>
<li>LinkedList   双向链表</li>
<li>HashSet       哈希表HashMap</li>
<li>TreeSet        红黑树（平衡排序二叉树）</li>
<li>ArrayDeque 可扩容动态双向数组</li>
<li>TreeMap       红黑树</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>ArrayList跟普通数组比起来可以动态地扩容或缩容，但是线程不安全。</p>
<p>Vector是List古老的实现类，线程安全，Stack就是继承于Vector</p>
<h4 id="删除和插入的时间复杂度"><a href="#删除和插入的时间复杂度" class="headerlink" title="删除和插入的时间复杂度"></a>删除和插入的时间复杂度</h4><ul>
<li><p>对于ArrayList，尾部插入与删除都是O(1)，其余都是O(N)</p>
</li>
<li><p>对于LinkedList，尾部和头部插入删除都是O(1)，其他都是O(N)</p>
</li>
</ul>
<p>虽然是这样，但是ArrayList的性能更好。</p>
<h4 id="RandomAcces接口"><a href="#RandomAcces接口" class="headerlink" title="RandomAcces接口"></a>RandomAcces接口</h4><p>这个接口就类似于<strong>Serializable</strong>接口，接口中并没有什么方法，起一个标识的作用，标识这个接口的类具有随机访问功能。</p>
<p>LinkedList并没有实现这个接口，主要是LinkedList的底层实现是链表，链表内存地址不连续。</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="Comparable和Comparator"><a href="#Comparable和Comparator" class="headerlink" title="Comparable和Comparator"></a>Comparable和Comparator</h4><ul>
<li>Comparable接口对应的是compareTo方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个类实现了Comparable接口，对Person对象中的年龄进行排序</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.age &gt; o.getAge()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.age &lt; o.getAge()) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>Comparator接口对应的是compare方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sort方法默认是升序，重写compare方法后改为降序</span></span><br><span class="line">Collections.sort(arrayList, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>Queue扩展了Collection的接口，对于插入、删除、查询队首元素分为了两类方法。建议还是使用返回特殊值，比较安全。</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">抛出异常</th>
<th align="center">返回特殊值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">插入</td>
<td align="center">add</td>
<td align="center">offer</td>
</tr>
<tr>
<td align="center">删除</td>
<td align="center">remove</td>
<td align="center">poll</td>
</tr>
<tr>
<td align="center">查询队首元素</td>
<td align="center">element</td>
<td align="center">peek</td>
</tr>
</tbody></table>
<h4 id="ArrayDeque和LinkedList"><a href="#ArrayDeque和LinkedList" class="headerlink" title="ArrayDeque和LinkedList"></a>ArrayDeque和LinkedList</h4><p><strong>Deque</strong>双端队列，可以同时在队头和队尾进行操作。</p>
<p>ArrayDeque和LinkedList都实现了Deque接口，他们的不同：</p>
<ul>
<li>底层实现不同，前者是可变长的数组和双指针，后者是链表</li>
<li>前者不可以存null数据，后者可以（对称二叉树有体现）</li>
</ul>
<h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><ul>
<li><p>底层是可变长的数组</p>
</li>
<li><p>优先队列是通过堆排序将优先级最高的元素放在队尾，插入与删除元素时间复杂度O(logn)。</p>
</li>
<li><p>非线程安全，不可以存储null</p>
</li>
<li><p>默认是小顶堆，数值排序的话就是降序排序，通过Comparator或lambda表达式可以改为大顶堆</p>
</li>
</ul>
<h4 id="BlockingQueue接口"><a href="#BlockingQueue接口" class="headerlink" title="BlockingQueue接口"></a>BlockingQueue接口</h4><p>当队列没有元素时一直阻塞，直到有元素；当队列已满，则会等到队列有元素出队之后再放入新元素——&gt;应用于生产者-消费者模型</p>
<p>BlockingQueue接口的实现类——ArrayBlockingQueue和LinkedBlockingQueue。</p>
<p>ArrayBlockingQueue支持公平和非公平的锁访问机制，LinkedBlockingQueue仅支持非公平；</p>
<p>所谓公平和非公平，就是是否按线程的请求顺序来获取锁。</p>
<blockquote>
<p>3.7</p>
</blockquote>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="HashMap和HashTable（基本被淘汰）"><a href="#HashMap和HashTable（基本被淘汰）" class="headerlink" title="HashMap和HashTable（基本被淘汰）"></a>HashMap和HashTable（基本被淘汰）</h4><ul>
<li>前者线程不安全，后者线程安全</li>
<li>HashMap可以存null键值对，null键只能存一次</li>
<li>HashMap初始容量大小16，扩充容量也是2的幂次方</li>
<li>HashMap底层在解决哈希冲突时，当链表长度大于阈值时，会转化为红黑树。</li>
</ul>
<h4 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h4><p>HashSet的底层基本都是HashMap实现的，HashSet的添加操作是直接调用了HashMap的put方法，而HashMap的put方法是比较对象的hashcode判断加入的位置，若有相同的hashcode，则会加入失败。</p>
<h4 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h4><h5 id="1-8之前"><a href="#1-8之前" class="headerlink" title="1.8之前"></a>1.8之前</h5><p>数组和链表结合在一起使用——<strong>拉链法</strong>，数组每一格就是一个链表，若哈希冲突，则将元素加入到链表中。</p>
<h5 id="1-8及之后"><a href="#1-8及之后" class="headerlink" title="1.8及之后"></a>1.8及之后</h5><p>在处理哈希冲突时，若链表长度大于阈值8，若当前数组长度小于64，则会进行数组扩容，否则会将链表转化为红黑树，为了提高搜索效率。</p>
<h4 id="HashMap的长度为什么是2的幂次方"><a href="#HashMap的长度为什么是2的幂次方" class="headerlink" title="HashMap的长度为什么是2的幂次方"></a>HashMap的长度为什么是2的幂次方</h4><p>若通过插入对象的哈希码和数组长度进行取模运算，则效率较慢。通过位运算可以更快地计算索引。</p>
<h4 id="HashMap为什么线程不安全"><a href="#HashMap为什么线程不安全" class="headerlink" title="HashMap为什么线程不安全"></a>HashMap为什么线程不安全</h4><p>假设两个线程同时进行put操作，然后计算出了相同的索引，第一个线程执行完哈希冲突后时间片结束，第二个线程完成了插入，第一个线程再次获得时间片，就会出现内容覆盖。</p>
<h4 id="数据扩容头插与尾插"><a href="#数据扩容头插与尾插" class="headerlink" title="数据扩容头插与尾插"></a>数据扩容头插与尾插</h4><p>1.8之前，hashmap采用的是头插法，是考虑到新插入的数据可能作为热点数据使用，放在头部可以减少查找时间；</p>
<p>1.8之后采用的是尾插法，为的是防止在多线程环境下出现环化。</p>
<p>多线程下头插法出现环化的问题：假设两个线程分别都插入一个数据A和B，前一个线程在准备插入时时间片用完，第二个线程进行扩容，因为是头插法，因此数据顺序是BA，但此时第一个线程的当前指针指向A，next指针指向B，它会先移动A，然后当前指针移向B，再插入B，由于第二个线程的next的指针的下一个next指针还是指向A，第一个线程还会再插入一次A，这样ABA，出现环化。</p>
<h4 id="ConcurrentHashMap底层实现"><a href="#ConcurrentHashMap底层实现" class="headerlink" title="ConcurrentHashMap底层实现"></a>ConcurrentHashMap底层实现</h4><h5 id="1-8之前-1"><a href="#1-8之前-1" class="headerlink" title="1.8之前"></a>1.8之前</h5><p>Segment分段锁设计。</p>
<p>为Segment数组结构加HashEntry数组结构。</p>
<p>Segment数组长度是固定的，为16；HashEntry用于存储键值对数据；一个Segment对应一个HashEntry。</p>
<p>通过对Segment加锁实现对HashEntry加锁，同时其他线程修改其他HashEntry是可以的，这就说明了Segment支持同时16个线程修改不同HashEntry的内容。</p>
<h5 id="1-8及之后-1"><a href="#1-8及之后-1" class="headerlink" title="1.8及之后"></a>1.8及之后</h5><p>基本数据结构和HashMap相同，但是对每个节点的插入和更新通过CAS操作和synchronized关键字在没有锁竞争的情况下完成，简单来说就是对Node数组中的节点的头部加锁，来保证线程安全。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><h5 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h5><p>无参构造方法创建ArrayList，实际上使用初始容量10构造了一个空数组。</p>
<p>当插入第一个元素时，此时数组长度还是0，会调用grow方法对列表进行扩容，初始扩容为10，当插入元素超过10时，会再次扩容。</p>
<p><strong>扩容的策略</strong>：扩容使数组的大小扩大为原来的1.5倍，为了实现高性能，是对旧容量大小进行了向右移位一位的操作，相当于对旧容量除以2，再加上旧容量，就相当于扩大为旧容量的1.5倍。（<strong>移位操作比普通运算符运算要快很多</strong>）</p>
<h5 id="ensureCapacity-方法"><a href="#ensureCapacity-方法" class="headerlink" title="ensureCapacity()方法"></a>ensureCapacity()方法</h5><p>提供给用户的接口，可以手动扩容ArrayList，主要是为了避免ArrayList频繁扩容影响性能。</p>
<h5 id="数组的复制"><a href="#数组的复制" class="headerlink" title="数组的复制"></a>数组的复制</h5><p>**System.arraycopy()<strong>和</strong>Arrays.copyOf()**方法</p>
<p>前者是一个本地方法，依赖底层系统，效率较高，而且是直接在目标数组上进行操作；</p>
<p>后者是一个工具类方法，它会创建一个新的数组，将原数组的元素复制到新数组中。</p>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>LinkedList的底层实现是一个双向链表，而且它还实现了Deque接口，可以在列表的首尾两端都进行操作。</p>
<p>LinkedList的get方法会通过比较索引值与链表size的一半大小来判断是从链表头还是链表尾开始遍历。</p>
<blockquote>
<p>3.9</p>
</blockquote>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><h5 id="loadFactor和threshold"><a href="#loadFactor和threshold" class="headerlink" title="loadFactor和threshold"></a>loadFactor和threshold</h5><p>负载因子和阈值，负载因子表示数组数据存放的疏密程度，越大表示存放的数据越多，一般设置为0.75；（<strong>负载因子可以手动设置</strong>）</p>
<p>阈值等于数组容量*负载因子，当数组中存放数据的量超过阈值后，会进行数组扩容。</p>
<h5 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h5><p>实际上是调用了putval方法添加元素。</p>
<p>当定位到的数组位置没有元素，直接放入；存在元素，对比key，key相同则覆盖，不相同则判断是否是树的节点（1.8后的哈希表中是有红黑树的），是就插入红黑树，否则就插入到链表中（尾插法）。</p>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><h5 id="1-7"><a href="#1-7" class="headerlink" title="1.7"></a>1.7</h5><p>ConcurrentHashMap由多个Segment组合而成，一个Segment相当于一个HashMap。HashMap的内部可以扩容，Segment的个数不能扩容，最大支持16。每个Segment的默认大小为2，当插入第二个元素时会进行扩容。</p>
<h5 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h5><p>1.8相比于1.7效率更高的地方在于减少了锁的使用，转而使用了CAS这种原子操作。</p>
<h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><p><code>ConcurrentHashMap</code> 的初始化是通过<strong>自旋和 CAS</strong> 操作完成的。</p>
<ul>
<li>自旋：线程等待的方式，不会让线程进入阻塞状态，会不断重试直至满足条件</li>
<li>CAS：compare and swap，不需要加锁，比较当前内存位置的值与预期值是否相等，相等则更新，否则就不操作。</li>
</ul>
<h6 id="put方法-1"><a href="#put方法-1" class="headerlink" title="put方法"></a>put方法</h6><p>首先尝试自旋+CAS加入元素，尝试了一定次数仍不能成功，则通过使用synchronized锁写入。</p>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h3 id="Java中的进程与线程"><a href="#Java中的进程与线程" class="headerlink" title="Java中的进程与线程"></a>Java中的进程与线程</h3><p>进程是程序的一次执行过程，是系统运行程序的基本单位，在Java中，启动了main函数就是启动了一个JVM的进程。</p>
<p>一个进程包含多个线程，多个线程共享进程的堆和方法区资源，每个线程有自己的程序计数器、虚拟机栈和本地方法栈，main函数所在的线程是JVM进程的主线程。</p>
<p>在JDK1.2之前，Java实现的是用户级线程，在JDK1.2及以后，Java实现的是内核级线程。这里的用户级和内核级就类似于操作系统中的用户态和内核态。</p>
<p>用户级无法使用多核。</p>
<p>在Windows和Linux中，Java采用的是一对一的线程模型，即一个Java线程对应一个内核级线程。</p>
<h3 id="详解Java线程"><a href="#详解Java线程" class="headerlink" title="详解Java线程"></a>详解Java线程</h3><p>各个线程私有：</p>
<ul>
<li>程序计数器：用于记录当前线程执行的位置——&gt;为了线程切换后能恢复到正确的执行位置</li>
<li>虚拟机栈：存储局部变量、常量池引用等信息</li>
<li>本地方法栈：正如其名，存储虚拟机使用到的本地方法。</li>
</ul>
<p>后两个私有主要是为了保证局部变量不被其他线程访问</p>
<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p>并发是程序在同一时间段执行</p>
<p>并行是程序在同一时刻执行</p>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>同步是发出一个调用之后，在未回应之前会一直等待；</p>
<p>异步是发出一个调用之后，调用会立即返回。</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="多线程的好处"><a href="#多线程的好处" class="headerlink" title="多线程的好处"></a>多线程的好处</h4><ul>
<li>线程是轻量级的进程，能够共享进程中的所有堆和方法区资源，线程间的切换和调度的成本远远小于进程</li>
<li>提高计算机的并发能力和性能</li>
</ul>
<h4 id="多线程的问题"><a href="#多线程的问题" class="headerlink" title="多线程的问题"></a>多线程的问题</h4><p>内存泄漏、死锁、线程不安全——&gt;对于同一份文件，多线程同时访问可能会导致数据出现错误。</p>
<h4 id="单核CPU执行多线程的问题"><a href="#单核CPU执行多线程的问题" class="headerlink" title="单核CPU执行多线程的问题"></a>单核CPU执行多线程的问题</h4><p>单核CPU在同一时刻只能有一个线程工作，若是CPU工作密集型，多线程会影响性能；若是I&#x2F;O密集型，多线程并发执行可以利用CPU等待IO完成的空闲时间，进行其他的计算。</p>
<h3 id="创建Java线程"><a href="#创建Java线程" class="headerlink" title="创建Java线程"></a>创建Java线程</h3><p>继承Thread类，通过new Thread().start()创建线程。不管是哪种方法，都会调用Thread类中的start方法来创建新线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ImplementsRunnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImplementsRunnable</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><ul>
<li>NEW新建  线程创建之后</li>
<li>RUNNABLE运行 调用start方法后等待运行</li>
<li>WAIT等待  调用wait方法，等待某些条件的满足</li>
<li>BLOCKED阻塞 synchroized方法，等待锁释放</li>
<li>超时等待  wait(time) 当超时之后会自动返回到运行状态</li>
<li>TERMINATED终止</li>
</ul>
<h4 id="线程的上下文切换"><a href="#线程的上下文切换" class="headerlink" title="线程的上下文切换"></a>线程的上下文切换</h4><p>将线程从CPU占用中退出：</p>
<ul>
<li>自己调用了sleep或者wait方法退出——&gt;等待</li>
<li>CPU时间片用完——&gt;REDAY</li>
<li>调用了阻塞类型的系统中断，线程被阻塞——&gt;阻塞</li>
</ul>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>这个单词本意就是不稳定的</p>
<ul>
<li><p>保证了变量的可见性，表示这个变量是共享且不稳定的，每次使用它都到主存中进行读取。这个可见性表示其他线程能看到这个线程中变量的修改。</p>
</li>
<li><p>防止JVM的指令重排序（JVM具有指令重排的特性）</p>
</li>
<li><p>不能保证变量的原子性。</p>
</li>
</ul>
<p>既保证可见性，又保证原子性——&gt;synchronized关键字</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>每次获取资源的时候都会上锁，当处理完资源再释放锁。</p>
<p>共享资源仅给一个线程使用，其他线程都会阻塞。比如synchronized关键字。</p>
<p>高并发场景下，悲观锁会造成大量阻塞，可能出现死锁问题。</p>
<p>悲观锁适合写占比较多的情况。</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁不限制线程对于资源的获取，在提交修改时会验证资源是否被修改了，若修改了，则线程本次修改失败。</p>
<p>常用方法：版本号机制、CAS算法——&gt;ConcurrentHashMap用CAS乐观锁替代了原来的synchronized悲观锁。</p>
<p>乐观锁适合读占比较多的情况，如果写比较多，则频繁的写失败也会影响性能。</p>
<h4 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h4><p>资源对应一个version变量，对资源进行修改，会使version变量加一，在处理前后对比version，一致则修改成功。</p>
<h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><p>V表示要更新的变量值，E表示预期值，N表示拟写入的新值，当V&#x3D;&#x3D;E时用N来更新V。</p>
<h4 id="乐观锁的问题"><a href="#乐观锁的问题" class="headerlink" title="乐观锁的问题"></a>乐观锁的问题</h4><ul>
<li>ABA问题 意思就是V确实等于E，并不能说明V没有修改过，他可能中间经历了某些修改使最终值还等于原来的值。</li>
</ul>
<p>解决ABA问题——CAS+版本号机制或时间戳</p>
<ul>
<li>循环时间长开销大       CAS通过自旋不断重试</li>
<li>只能保证一个共享变量的原子操作     CAS只对一个共享变量有效</li>
</ul>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>修饰实例方法——锁当前对象实例</p>
<p>修饰静态方法——锁当前类</p>
<p>构造方法不可以用synchronized关键字修饰，构造方法本身就是线程安全的。</p>
<h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4><ul>
<li>同步代码块：1个monitorenter指令指向同步代码块的开始位置，两个monitorexit指令指向同步代码块的结束位置。为了处理异常情况。</li>
<li>方法：ACC_SYNCHRONIZED标识</li>
</ul>
<p>本质上都是对对象监视器monitor的获取。</p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>有一个内部类Sync，Sync继承了AQS，添加锁和释放锁都是在Sync中实现的</p>
<p>ReentrantLock默认使用非公平锁，也可以通过构造函数显式的指定使用公平锁。</p>
<h4 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h4><ul>
<li>R更灵活，增加了轮询、超时、中断等功能。</li>
<li>synchronized是非公平锁，R可以指定公平锁或非公平锁。</li>
<li>synchronized依赖于JVM实现，R基于JDK层面实现。</li>
</ul>
<h3 id="可重入锁的实现原理"><a href="#可重入锁的实现原理" class="headerlink" title="可重入锁的实现原理"></a>可重入锁的实现原理</h3><p>为每个锁维护一个拥有者线程标识和计数器，在加锁和解锁操作时对计数器进行递增和递减，并通过并发控制确保线程对锁状态的访问是安全的。</p>
<p>如ReentrantLock，在内部维护了一个锁状态变量和一个等待队列，等待队列会阻塞等待获取锁的线程。在获取锁的时候，会判断当前锁状态变量是否为0，如果为0，则获取到锁，且锁状态变量+1，这时其他锁线程无法获取到锁，当获取锁的同一个线程再次获取锁时，则锁状态变量会再加一。当锁状态变量变为0才会真正释放锁。</p>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>信号量，好像是在操作系统的生产-消费者模型中学到的。</p>
<p>Semaphore控制同时访问特定资源的线程数量。</p>
<p>分为两种模式：非公平模式和公平模式，对应了是否满足FIFO</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>普通的变量可以被所有的线程访问并修改，ThreadLocal使变量专属于某个线程。</p>
<p>对于ThreadLocal变量，访问这个变量的每一个线程都会保存这个变量的本地副本。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>ThreadLocal本质上就是使用一个ThreadLocalMap（客制化的HashMap）存储每个线程的变量副本。</p>
<p>调用ThreadLocal类的set和get方法，实际上调用的是ThreadLocalMap类的set和get方法。</p>
<p>ThreadLocalMap的key为ThreadLocal类，value为变量副本。</p>
<h4 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h4><p>ThreadLocalMap的key是一个弱引用，value是强引用。当外部没有对ThreadLocal对象没有直接引用时，GC会回收ThreadLocal对象，然而value强引用不会清理，这就造成了内存泄露。通过remove方法可以清理key为null的所有value。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>类似于数据库连接池，为了更好地管理线程，减少创建线程和销毁线程造成的损耗、提高线程响应的速度。</p>
<h4 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h4><p>多种类型的ThreadPoolExecutor</p>
<ul>
<li>FixedThreadPool  固定线程数量的线程池</li>
<li>SingleThreadPool 单线程线程池</li>
</ul>
<p>使用的是无界的LinkedBlockQueue任务阻塞队列，有最大长度，为Integer.MAX_VALUE</p>
<ul>
<li>CachedThreadPool  根据实际情况调整线程的数量</li>
</ul>
<p>使用的是同步队列SynchronousQueue，有最大长度，为Integer.MAX_VALUE</p>
<ul>
<li>ScheduledThreadPool  定期执行任务的线程池</li>
</ul>
<p>使用的是无界的延迟阻塞队列DelayedWorkQueue，有最大长度，为Integer.MAX_VALUE</p>
<p>这几种方法都可能导致OOM，即程序运行过程中内存耗尽而无法继续执行的情况。</p>
<h4 id="线程池的参数"><a href="#线程池的参数" class="headerlink" title="线程池的参数"></a>线程池的参数</h4><ul>
<li>corePoolSize:任务队列未达到最大长度时，最大可以同时运行的线程数量  <strong>核心线程数</strong></li>
<li>maximumPoolSize:任务队列中达到最大长度时，核心线程数变为最大线程数</li>
<li>workQueue:新任务判断当前同时运行的线程数量是否达到核心线程数，若达到了，进入任务队列</li>
<li>keepAliveTime:线程数大于核心线程数时，任务队列中没有任务，不会立即销毁线程，等待keepAliveTime的时间</li>
</ul>
<h4 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h4><p>当任务队列已满，并且线程池中已经运行了最大线程数，默认是抛出异常拒绝新来的任务，也可以使用调用该任务的线程来处理，或者丢弃最早的未处理的任务请求。</p>
<h4 id="线程池处理任务的流程"><a href="#线程池处理任务的流程" class="headerlink" title="线程池处理任务的流程"></a>线程池处理任务的流程</h4><p>先看核心线程数，达到了就进入队列，要是队列也满了，进入线程池调用非核心线程，若线程池也满了，则按饱和策略对任务处理。</p>
<h4 id="线程池的大小"><a href="#线程池的大小" class="headerlink" title="线程池的大小"></a>线程池的大小</h4><p>线程池开的太大的话，会导致大量线程同时争取CPU资源，会有大量的上下文切换，从而增加线程的执行时间。</p>
<p>合适的线程池的大小：</p>
<ul>
<li>CPU密集型任务    N + 1</li>
<li>I&#x2F;O密集型   2 * N</li>
</ul>
<p>N为CPU核心数</p>
<h4 id="动态修改线程池的参数"><a href="#动态修改线程池的参数" class="headerlink" title="动态修改线程池的参数"></a>动态修改线程池的参数</h4><p>主要就是线程池的前三个参数，为了修改队列的长度，美团实现了一个非final修饰的LinkedBlockQueue的队列。</p>
<h4 id="现成的线程池框架"><a href="#现成的线程池框架" class="headerlink" title="现成的线程池框架"></a>现成的线程池框架</h4><p>Hippo4j     这个是12306的作者实现的</p>
<h4 id="根据任务优先级执行"><a href="#根据任务优先级执行" class="headerlink" title="根据任务优先级执行"></a>根据任务优先级执行</h4><p>任务队列使用PriorityBlockingQueue，是线程安全的PriorityQueue。</p>
<p>PriorityBlockingQueue也是无界的，可能会造成OOM问题；由于是优先队列，因此低优先级的任务会导致饥饿问题，一直得不到执行；由于要不停的对队列中的任务进行优先级排序并且要保证线程安全，会降低性能。</p>
<h4 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h4><ul>
<li>shutdown：线程池状态变为SHUTDOWN，线程池不再接受新任务，但是会执行完队列中的任务</li>
<li>shutdownNow：线程池状态变为STOP，线程池会停止所有正在执行的任务，并且取消所有已提交但未执行的任务</li>
</ul>
<h4 id="为不同业务设计不同的线程池"><a href="#为不同业务设计不同的线程池" class="headerlink" title="为不同业务设计不同的线程池"></a>为不同业务设计不同的线程池</h4><p>一个是对不同的业务，核心线程数、最大线程数和阻塞队列的大小都要与之匹配；二是如果两个业务之间有耦合关系，若其中一个业务占用了线程池中的所有线程，会导致死锁。</p>
<h2 id="JMM-Java内存模型"><a href="#JMM-Java内存模型" class="headerlink" title="JMM    Java内存模型"></a>JMM    Java内存模型</h2><h3 id="CPU缓存和内存缓存"><a href="#CPU缓存和内存缓存" class="headerlink" title="CPU缓存和内存缓存"></a>CPU缓存和内存缓存</h3><ul>
<li>CPU缓存解决了CPU和内存速度不匹配的问题</li>
<li>内存缓存解决了内存和外存速度不匹配的问题</li>
</ul>
<p>CPU在实际执行中，会将一份数据写入到CPU缓存中，当运算完成后，再写入到主存中，但是这样就有可能出现<strong>内存缓存不一致</strong>的问题，若多个线程同时对一个变量进行更新，则CPU缓存中的变量更新了而内存缓存中的变量没有更新。因此要通过<strong>内存模型</strong>解决这个问题。</p>
<h3 id="Java-Memory-Model"><a href="#Java-Memory-Model" class="headerlink" title="Java Memory Model"></a>Java Memory Model</h3><p>为不同操作系统设计不同的JMM，类似于JVM，保证可移植性。</p>
<h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><p>类似于CPU缓存和内存缓存，<strong>线程的共享变量必须存储在主内存中，每个线程都有一个私有的本地内存，线程对共享变量的修改都是在本地内存中进行，并同步到主内存中</strong>，Java设置了synchronized、volatile等关键字（JVM优化）和Lock接口（JDK实现）来实现对共享变量的安全访问。</p>
<h4 id="JMM和Java内存区域"><a href="#JMM和Java内存区域" class="headerlink" title="JMM和Java内存区域"></a>JMM和Java内存区域</h4><p>JMM定义了Java程序中多线程并发访问共享内存的规则和保证，Java内存区域是JVM在运行时的内存空间。</p>
<h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><p>如果一个操作happens-before另一个操作，那么第一个操作的执行结果对第二个操作可见。</p>
<h4 id="并发编程的重要特性"><a href="#并发编程的重要特性" class="headerlink" title="并发编程的重要特性"></a>并发编程的重要特性</h4><ul>
<li>原子性</li>
<li>可见性</li>
<li>有序性</li>
</ul>
<h3 id="Atomic原子类"><a href="#Atomic原子类" class="headerlink" title="Atomic原子类"></a>Atomic原子类</h3><p>原子类就是具有原子性特征的类</p>
<p>对于基本数据类型原子类，不需要给其加锁也可以实现线程安全。</p>
<h2 id="I-O-1"><a href="#I-O-1" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h2><h3 id="I-O设计模式"><a href="#I-O设计模式" class="headerlink" title="I&#x2F;O设计模式"></a>I&#x2F;O设计模式</h3><h4 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h4><p>在不改变原有对象的情况下拓展其功能</p>
<p>比如FilterInputStream增强InputStream的功能。</p>
<h4 id="适配者模式"><a href="#适配者模式" class="headerlink" title="适配者模式"></a>适配者模式</h4><p>让接口不兼容而不能交互的类可以一起工作，如InputStreamReader实现字节流到字符流的转换。</p>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>用来创建对象</p>
<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>用于监听文件目录的变化，监听的三种事件——文件创建、文件删除、文件修改</p>
<h3 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I&#x2F;O模型"></a>I&#x2F;O模型</h3><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>同步阻塞IO模型，应用程序发起read调用后，会一直阻塞直到内核把数据拷贝到用户空间</p>
<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>同步非阻塞IO模型，应该程序会一直发起read调用（轮询）</p>
<p>多路复用模型，线程先发起select调用，询问内核数据是否准备就绪，若就绪了，再发起read调用。</p>
<h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4><p>异步IO模型</p>
<h2 id="JVM-1"><a href="#JVM-1" class="headerlink" title="JVM"></a>JVM</h2><h3 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h3><ul>
<li>线程共享：堆、本地内存</li>
<li>线程私有：程序计数器、虚拟机栈、本地方法栈</li>
</ul>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 ）"></p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>Java几乎所有的对象实例都是存入堆中。</p>
<p>堆是GC管理的主要区域，因此也称为GC堆，为了更好地回收内存，将堆内存分为了多个生代——新生代、老生代、永久代，永久代在本地内存的元空间中。</p>
<p>新生代区分为一个eden区和两个survivor区。</p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><h4 id="内存分配和回收规则"><a href="#内存分配和回收规则" class="headerlink" title="内存分配和回收规则"></a>内存分配和回收规则</h4><p>大多数情况下，对象在新生代eden区中分配，若新生代eden区中的内存不够分配时，则虚拟机会发起一次Minor GC新生代垃圾收集，若对象熬过一次Minor GC，且能被survivor容纳，则移动到survivor区，每在survivor区生存过一轮Minor GC，则年龄增加一岁，当15岁时，会进入老年代中。</p>
<p>大对象（需要大量连续内存空间的对象）直接进入老年代中，减少新生代的垃圾回收频率和成本。</p>
<h5 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h5><p>在每次进行Minor GC之前，都会检查老年代最大可用的连续空间是否大于新生代所有对象总空间。</p>
<h5 id="为什么新生代需要有两个survivor区"><a href="#为什么新生代需要有两个survivor区" class="headerlink" title="为什么新生代需要有两个survivor区"></a>为什么新生代需要有两个survivor区</h5><p>如果只有一个survivor区的话，由于survivor区中也有死亡的对象，这样survivor区就出现了内存碎片，然而survivor区还有很多对象年龄还没有到，不能清理survivor区中的对象到老年代中。</p>
<p>有两个survivor区的话，相当于标记-复制算法，当Eden区满了之后会触发一次minor gc，将Eden区和s0区中存活的对象都写入s1区中，为了避免不断地在两个s区之间复制对象，此时将空的s0区作为原来的s1区使用。</p>
<h4 id="死亡对象判断方法"><a href="#死亡对象判断方法" class="headerlink" title="死亡对象判断方法"></a>死亡对象判断方法</h4><ul>
<li>引用计数法：计算每个对象的被引用次数，若为0，则需要回收。             <strong>可能遇到循环引用的问题</strong></li>
<li>可达性分析：设置一个<strong>GC Roots</strong>对象作为起点，从这个起点往下搜索，若不可达某个对象，则这个对象需要被回收。</li>
</ul>
<h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><ul>
<li>强引用</li>
<li>软引用：内存空间足够，不会回收，不够则会回收</li>
<li>弱引用：无论内存空间是否足够都会回收</li>
</ul>
<h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><h5 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h5><p>标记出所有不需要回收的对象，标记完成后同一回收掉所有没有被标记的对象。</p>
<p>标记和清除的效率都不高，而且清除后会产生大量不连续的内存。</p>
<h5 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h5><p>将内存分为大小相同的两块，每次使用其中的一块，当一块中的内存使用完后，就将还存活的内存复制到另一块中去，然后将使用的空间一次清理掉。</p>
<h5 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h5><p>对于被标记的对象，让其向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><strong>为什么堆要分为新生代和老年代？</strong>  方便采用不同的垃圾回收算法来处理对象。</p>
<p>对于新生代，每次收集都会有大量对象死去，只需要将存活的对象复制到另一块中，采用复制算法；对于老年代，没有额外的空间进行分配担保，则采用标记-清除和标记-整理算法。</p>
<h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><h5 id="serial"><a href="#serial" class="headerlink" title="serial"></a>serial</h5><p>单线程垃圾收集器，工作时会阻塞所有线程</p>
<p>新生代标记-复制，老年代标记-清除</p>
<h5 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h5><p>serial的多线程版本</p>
<h5 id="parallel-scavenge"><a href="#parallel-scavenge" class="headerlink" title="parallel scavenge"></a>parallel scavenge</h5><p>侧重于提高吞吐量，减少垃圾收集时的停顿时间</p>
<h5 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h5><p>concurrent mark sweep并发标记清除</p>
<p>侧重于用户线程的停顿时间，来提高用户体验。</p>
<p>一款并发收集器，实现了让垃圾收集线程和用户线程同时工作。</p>
<p>工作流程：</p>
<ul>
<li>初始标记：暂停所有线程，记录下与root相连的对象</li>
<li>并发标记：同时开启GC和用户线程，通过可达性分析找到可达的对象</li>
<li>重新标记：由于用户线程会不断更新引用域，因此并发标记做不到实时性，对用户线程更新产生变动的那部分对象的标记记录进行修正</li>
<li>并发清除：开启用户线程，同时GC线程开始清除未标记的对象</li>
</ul>
<h5 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h5><p>JDK9~21</p>
<ul>
<li>并行与并发：并发阶段，G1和应用程序线程并发执行，减少停顿时间；部分收集阶段，G1使用多个线程并行收集垃圾</li>
<li>内存整理：尽量避免产生内存碎片，通过空闲区域的合并和整理减少内存碎片化的问题。</li>
<li>自适应的停顿时间控制：根据用户设定的停顿时间自适应调整垃圾收集策略</li>
</ul>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/class-loading-procedure.png" alt="类加载过程"></p>
<p>加载Java的字节码（.class文件）到JVM中（在内存中生成一个代表该类的Class对象）</p>
<p>JVM启动的时候，并不会一次性加载所有的类，而是根据需要动态加载——减少内存负荷</p>
<h4 id="类加载器类型"><a href="#类加载器类型" class="headerlink" title="类加载器类型"></a>类加载器类型</h4><ul>
<li>启动类加载器</li>
<li>扩展类加载器</li>
<li>应用程序类加载器</li>
<li>自定义类加载器</li>
</ul>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>加载一个类由哪个类加载器加载？——引出双亲委派模型</p>
<p>类加载器实例在亲自查找类和资源之前，会将这个任务委托给其父类加载器。（启动类加载器的父类加载器还是其本身。）</p>
<p><strong>类加载器之间的关系不是以继承的关系实现，而是使用组合关系（在一个类中创建其他类的对象）</strong></p>
<p>类加载器在类加载时，会委派给父类加载器去完成，这样一层一层的往上委派，最终都会传送到顶层的启动类加载器。若往上的委派中父类加载器反馈自己无法完成加载请求，子加载器才会尝试自己加载。</p>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><h4 id="spring中的单例bean是线程安全的吗？"><a href="#spring中的单例bean是线程安全的吗？" class="headerlink" title="spring中的单例bean是线程安全的吗？"></a>spring中的单例bean是线程安全的吗？</h4><p>spring中的bean默认是单例模式，可以修改为多例模式。</p>
<p><strong>spring中的单例bean不是线程安全的，</strong>一般情况下spring的bean都是注入无状态的对象，没有线程安全问题；但是如果在bean中定义了可修改的变量，线程就不安全了，要靠多例模式或者加锁来实现线程安全。</p>
<p>线程不安全的例子：项目中设置一个计数器服务，创建一个bean来记录。</p>
<h4 id="AOP的应用"><a href="#AOP的应用" class="headerlink" title="AOP的应用"></a>AOP的应用</h4><p>面向切面编程，核心是代理模式，在原有的功能上进行增强。</p>
<ul>
<li><strong>记录操作日志</strong>   通过环绕通知记录业务的日志，减少与业务类代码的耦合</li>
<li><strong>Spring中内置的事务处理</strong>     <strong>声明式事务管理</strong>    通过环绕通知捕捉异常实现事务的执行或者回滚</li>
</ul>
<h4 id="spring事务失效的场景"><a href="#spring事务失效的场景" class="headerlink" title="spring事务失效的场景"></a>spring事务失效的场景</h4><ul>
<li><strong>异常捕获处理</strong>    虽然AOP实现的事务可以实现异常的捕获和回滚，但是如果在业务代码中通过catch捕获异常了，则异常以下的代码不会被执行，这样不满足原子性。解决方法：在catch中抛出异常</li>
<li><strong>抛出检查异常</strong>   解决方法：在@Transactional注解中配置rollbackFor属性，设置为所有异常</li>
<li><strong>非public方法</strong>   创建代理、添加事务通知的方法必须是public的。</li>
</ul>
<h4 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h4><p><strong>通过BeanDefinition获取bean的定义信息</strong></p>
<p>bean的创建分为两步：bean对象的创建和bean对象方法的创建（初始化赋值）</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240325145435343.png" alt="image-20240325145435343"></p>
<p>构造函数就是对象的创建过程，后续都是对象方法的创建，其中依赖注入是注入对象以及成员变量的值。</p>
<h4 id="spring如何解决循环依赖问题"><a href="#spring如何解决循环依赖问题" class="headerlink" title="spring如何解决循环依赖问题"></a>spring如何解决循环依赖问题</h4><p>Spring通过使用三级缓存来解决循环依赖问题。<strong>bean的创建分为两步：对象的实例化和对象属性的实例化</strong>  未对象属性实例化的对象称为半成品对象</p>
<p>一级缓存存储已完全初始化的对象，二级缓存存储半成品对象，三级缓存只是对象的创建委托。</p>
<p>spring中的循环依赖对象的创建过程：</p>
<ol>
<li>A创建过程中依赖B，则A进入三级缓存中，再去实例化B</li>
<li>B创建过程中依赖A，则查找缓存中是否有A，发现三级缓存中有A，则将A放入二级缓存中，并删除三级缓存中的A。</li>
<li>B创建完成，将B放入一级缓存中，此时A还是半成品对象，然后继续创建A，A依赖B，这时去查缓存，发现B在一级缓存中，直接取B完成创建，最后完成创建A，将A放入一级缓存中。</li>
</ol>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><h4 id="执行流程——前后端分离"><a href="#执行流程——前后端分离" class="headerlink" title="执行流程——前后端分离"></a>执行流程——前后端分离</h4><ol>
<li>用户发出请求到前端控制器</li>
<li>前端控制器收到请求调用处理器映射器</li>
<li>处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器，再一起返回给前端控制器；</li>
<li>前端控制器调用处理器适配器，处理器适配器经过适配调用具体的处理器</li>
<li>在方法上添加了@ResponseBody，通过HttpMessageConverter来返回结果转换为JSON并响应。</li>
</ol>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240325153922367.png" alt="image-20240325153922367"></p>
<h3 id="Springboot"><a href="#Springboot" class="headerlink" title="Springboot"></a>Springboot</h3><h4 id="springboot自动配置原理"><a href="#springboot自动配置原理" class="headerlink" title="springboot自动配置原理"></a>springboot自动配置原理</h4><ol>
<li>springboot项目的入口类上有一个注解@SpringBootApplication，这个注解包含3个注解，分别为@SpringBootConfiguration、@EnableAutoConfiguation和@ComponentScan</li>
<li><strong>@EnableAutoConfiguation</strong>实现自动化配置的核心注解，该注解通过@Import注解导入对应的配置选择器。所有的自动配置类都会在“META-INF&#x2F;spring.factories”文件中，位于对应的自动配置jar包中。</li>
<li>@ConditionalOnClass注解会判断是否有对应的class文件，如果有则加载该类，将该类的bean放入spring容器中。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jiangduwang.github.io/2024/06/03/Java/" data-id="clwyjx9fb0000jkuld2b9606l" data-title="java八股" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-sql" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/03/sql/" class="article-date">
  <time class="dt-published" datetime="2024-06-03T05:49:25.172Z" itemprop="datePublished">2024-06-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/06/03/sql/">sql语句</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="字段为null的情况"><a href="#字段为null的情况" class="headerlink" title="字段为null的情况"></a>字段为null的情况</h2><p>字段为null的情况，不可以用&#x3D;来判断，两种方式处理：1、用 is 来判断null；2、用IFNULL将null替换为一个有效的值再判断</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> Customer <span class="keyword">WHERE</span> referee_id <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">OR</span> referee_id <span class="operator">!=</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> Customer <span class="keyword">WHERE</span> IFNULL(referee_id, <span class="number">0</span>) <span class="operator">!=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>



<h2 id="去重查询"><a href="#去重查询" class="headerlink" title="去重查询"></a>去重查询</h2><p>如果要查询的列不是主键的话，会出现重复的情况，要用 <strong>DISTINCT</strong>关键字来去重</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> author_id <span class="keyword">as</span> id <span class="keyword">FROM</span> Views <span class="keyword">WHERE</span> author_id <span class="operator">=</span> viewer_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> author_id</span><br></pre></td></tr></table></figure>



<h2 id="计算字符数"><a href="#计算字符数" class="headerlink" title="计算字符数"></a>计算字符数</h2><ul>
<li>CHAR_LENGTH     计算字符数，汉字也算一个字符</li>
<li>LENGTH                 计算字节数，UTF8汉字三个字节</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT tweet_id FROM Tweets WHERE <span class="title function_">CHAR_LENGTH</span><span class="params">(content)</span> &gt; <span class="number">15</span></span><br></pre></td></tr></table></figure>



<h2 id="左连接和右连接"><a href="#左连接和右连接" class="headerlink" title="左连接和右连接"></a>左连接和右连接</h2><p>左连接从左表（LEFT JOIN前面的表）中返回所有记录，即使右表中没有匹配的记录。右表中如果没有匹配，则结果中右表的部分会包含NULL。</p>
<h3 id="使用唯一标识替换员工ID"><a href="#使用唯一标识替换员工ID" class="headerlink" title="使用唯一标识替换员工ID"></a>使用唯一标识替换员工ID</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">Employees 表:</span><br><span class="line">+----+----------+</span><br><span class="line">| id | name     |</span><br><span class="line">+----+----------+</span><br><span class="line">| 1  | Alice    |</span><br><span class="line">| 7  | Bob      |</span><br><span class="line">| 11 | Meir     |</span><br><span class="line">| 90 | Winston  |</span><br><span class="line">| 3  | Jonathan |</span><br><span class="line">+----+----------+</span><br><span class="line">EmployeeUNI 表:</span><br><span class="line">+----+-----------+</span><br><span class="line">| id | unique_id |</span><br><span class="line">+----+-----------+</span><br><span class="line">| 3  | 1         |</span><br><span class="line">| 11 | 2         |</span><br><span class="line">| 90 | 3         |</span><br><span class="line">+----+-----------+</span><br><span class="line">输出：</span><br><span class="line">+-----------+----------+</span><br><span class="line">| unique_id | name     |</span><br><span class="line">+-----------+----------+</span><br><span class="line">| null      | Alice    |</span><br><span class="line">| null      | Bob      |</span><br><span class="line">| 2         | Meir     |</span><br><span class="line">| 3         | Winston  |</span><br><span class="line">| 1         | Jonathan |</span><br><span class="line">+-----------+----------+</span><br><span class="line">解释：</span><br><span class="line">Alice and Bob 没有唯一标识码, 因此我们使用 null 替代。</span><br><span class="line">Meir 的唯一标识码是 2 。</span><br><span class="line">Winston 的唯一标识码是 3 。</span><br><span class="line">Jonathan 唯一标识码是 1 。</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> u.unique_id, e.name <span class="keyword">FROM</span> Employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> EmployeeUNI u <span class="keyword">on</span> u.id <span class="operator">=</span> e.id</span><br></pre></td></tr></table></figure>

<p>这题主表是Employees表，为了实现null替代，用左连接比较好，如果没有null的情况，下面这样写也是可以的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> u.unique_id, e.name <span class="keyword">FROM</span> Employees e, EmployeeUNI u <span class="keyword">WHERE</span> u.id <span class="operator">=</span> e.id</span><br></pre></td></tr></table></figure>



<h3 id="进店却未进行过交易的顾客"><a href="#进店却未进行过交易的顾客" class="headerlink" title="进店却未进行过交易的顾客"></a>进店却未进行过交易的顾客</h3><blockquote>
<p>有一些顾客可能光顾了购物中心但没有进行交易。请你编写一个解决方案，来查找这些顾客的 ID ，以及他们只光顾不交易的次数。</p>
<p>返回以 <strong>任何顺序</strong> 排序的结果表。</p>
<p>返回结果格式如下例所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">Visits</span><br><span class="line">+----------+-------------+</span><br><span class="line">| visit_id | customer_id |</span><br><span class="line">+----------+-------------+</span><br><span class="line">| 1        | 23          |</span><br><span class="line">| 2        | 9           |</span><br><span class="line">| 4        | 30          |</span><br><span class="line">| 5        | 54          |</span><br><span class="line">| 6        | 96          |</span><br><span class="line">| 7        | 54          |</span><br><span class="line">| 8        | 54          |</span><br><span class="line">+----------+-------------+</span><br><span class="line">Transactions</span><br><span class="line">+----------------+----------+--------+</span><br><span class="line">| transaction_id | visit_id | amount |</span><br><span class="line">+----------------+----------+--------+</span><br><span class="line">| 2              | 5        | 310    |</span><br><span class="line">| 3              | 5        | 300    |</span><br><span class="line">| 9              | 5        | 200    |</span><br><span class="line">| 12             | 1        | 910    |</span><br><span class="line">| 13             | 2        | 970    |</span><br><span class="line">+----------------+----------+--------+</span><br><span class="line">输出:</span><br><span class="line">+-------------+----------------+</span><br><span class="line">| customer_id | count_no_trans |</span><br><span class="line">+-------------+----------------+</span><br><span class="line">| 54          | 2              |</span><br><span class="line">| 30          | 1              |</span><br><span class="line">| 96          | 1              |</span><br><span class="line">+-------------+----------------+</span><br><span class="line">解释:</span><br><span class="line">ID = 23 的顾客曾经逛过一次购物中心，并在 ID = 12 的访问期间进行了一笔交易。</span><br><span class="line">ID = 9 的顾客曾经逛过一次购物中心，并在 ID = 13 的访问期间进行了一笔交易。</span><br><span class="line">ID = 30 的顾客曾经去过购物中心，并且没有进行任何交易。</span><br><span class="line">ID = 54 的顾客三度造访了购物中心。在 2 次访问中，他们没有进行任何交易，在 1 次访问中，他们进行了 3 次交易。</span><br><span class="line">ID = 96 的顾客曾经去过购物中心，并且没有进行任何交易。</span><br><span class="line">如我们所见，ID 为 30 和 96 的顾客一次没有进行任何交易就去了购物中心。顾客 54 也两次访问了购物中心并且没有进行任何交易。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这一题思路要分成几步来看，第一步使用左连接，计算出customer_id对应的transaction_id，如果customer_id对应的transaction_id列为null，则说明只逛过没有交易，然后计算每个customer_id对应的null的个数，按customer_id进行分组，最终得到结果。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="built_in">COUNT</span>(customer_id) <span class="keyword">as</span> count_no_trans <span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Transactions <span class="keyword">ON</span> Customers.visit_id <span class="operator">=</span> Transactions.visit_id</span><br><span class="line"><span class="keyword">WHERE</span> transaction_id <span class="keyword">is</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id</span><br></pre></td></tr></table></figure>

<h2 id="日期比较"><a href="#日期比较" class="headerlink" title="日期比较"></a>日期比较</h2><p>DATEDIFF(endDate, startDate) 计算两个日期相差的天数</p>
<h3 id="上升的温度"><a href="#上升的温度" class="headerlink" title="上升的温度"></a>上升的温度</h3><blockquote>
<p>编写解决方案，找出与之前（昨天的）日期相比温度更高的所有日期的 <code>id</code> 。</p>
<p>返回结果 <strong>无顺序要求</strong> 。</p>
<p>结果格式如下例子所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">Weather 表：</span><br><span class="line">+----+------------+-------------+</span><br><span class="line">| id | recordDate | Temperature |</span><br><span class="line">+----+------------+-------------+</span><br><span class="line">| 1  | 2015-01-01 | 10          |</span><br><span class="line">| 2  | 2015-01-02 | 25          |</span><br><span class="line">| 3  | 2015-01-03 | 20          |</span><br><span class="line">| 4  | 2015-01-04 | 30          |</span><br><span class="line">+----+------------+-------------+</span><br><span class="line">输出：</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">| 2  |</span><br><span class="line">| 4  |</span><br><span class="line">+----+</span><br><span class="line">解释：</span><br><span class="line">2015-01-02 的温度比前一天高（10 -&gt; 25）</span><br><span class="line">2015-01-04 的温度比前一天高（20 -&gt; 30）</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.id <span class="keyword">FROM</span> Weather a, Weather b <span class="keyword">WHERE</span> DATEDIFF(a.recordDate, b.recordDate) <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> a.Temperature <span class="operator">&gt;</span> b.Temperature</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://jiangduwang.github.io/2024/06/03/sql/" data-id="clwyjx9fg0001jkul7wrb25hr" data-title="sql语句" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-kafka" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/03/kafka/" class="article-date">
  <time class="dt-published" datetime="2024-06-03T05:49:25.109Z" itemprop="datePublished">2024-06-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/06/03/kafka/">kafka八股</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>Message Queue，简称MQ</p>
<p>将需要传输的数据存放在队列中</p>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>用来存储消息的组件，比如Kafka、RocketMQ、RabbitMQ</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h4><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240316171521493.png" alt="image-20240316171521493"></p>
<p>快速响应，避免串行导致的高延迟</p>
<h4 id="系统解耦"><a href="#系统解耦" class="headerlink" title="系统解耦"></a>系统解耦</h4><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240316172043220.png" alt="image-20240316172043220"></p>
<h4 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h4><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240316172522210.png" alt="image-20240316172522210"></p>
<h4 id="日志处理"><a href="#日志处理" class="headerlink" title="日志处理"></a>日志处理</h4><p>主要用来处理用户的喜好和活跃情况</p>
<h2 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h2><p>将消息队列放入到硬盘中，利用硬盘顺序读写性能高的特点处理消息队列，然后又能保证高吞吐量。</p>
<p>kafka跟ros差不多，也是设置一个主题，然后生产者类似于发布者，在主题上发布消息；消费者类似于订阅者，通过主题接收消息，然后会有对应的一个处理函数（回调函数）</p>
<h3 id="发送系统通知"><a href="#发送系统通知" class="headerlink" title="发送系统通知"></a>发送系统通知</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>对于评论、点赞和关注，分别设置不同的主题，生产者线程只负责将这些行为写入到消息队列中，后续的操作都是消费者线程去完成，这样就实现了异步。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>进行上面的行为需要封装一个事件的实体类，让这个实体类内中封装消费者可能需要的数据，然后让实体类的对象作为消息（这里是将对象转为json字符串）写入到消息队列中去。</p>
<p>消费者线程会读出消息队列中的内容，写入到数据库message表中，实现系统通知就是你进入通知页面，会对message表进行查询，然后将相关信息传回前端。</p>
<h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><ul>
<li>分布式的、restful风格的搜索引擎</li>
<li>便于水平拓展，每秒可以处理海量数据</li>
</ul>
<p>在搜索之前，需要存一份副本到搜索引擎中去</p>
<h3 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h3><p>原生ES不支持中文分词，需要下载一个叫iK的插件实现能够检索中文分词</p>
<h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><p>类似于数据库，es可以把数据库中的记录（一般是关键的字段，如果是帖子，就是标题和内容，通过注解来区分）存储到索引中，在索引中可以对记录进行增删改查。</p>
<h3 id="全局搜索"><a href="#全局搜索" class="headerlink" title="全局搜索"></a>全局搜索</h3><p>实现一个NativeSearchQueryBuilder类，设置查询的关键字、查询的字段；设置排序的字段；设置分页；设置高亮字段。</p>
<p>上面的高亮字段并不是真的实现对搜索字段添加标签，它直接返回的还是包含搜索字段的内容，实现高亮字段需要重写elasticsearchTemplate中的mapResults方法。</p>
<p>新建帖子时，将帖子对象异步写入ES中；删除帖子时，会异步删除ES中的内容。 这里的异步都是消息队列实现的。</p>
<h2 id="kafka八股"><a href="#kafka八股" class="headerlink" title="kafka八股"></a>kafka八股</h2><h3 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h3><p>早期使用的是队列模型，使用队列作为消息通信载体，但是使用队列有一些问题，一条消息只能被一个消费者使用，如果我想多个消费者消费同一条消息（广播），则实现不了。</p>
<p>现在使用的是<strong>发布-订阅模型</strong>，使用主题topic作为消息通信载体，一个生产者发布了一个主题，则所有订阅了这个主题的消费者都能接收到消息（广播），当只有一个消费者的时候，就退化成了队列模型。</p>
<h3 id="Broker与Partition"><a href="#Broker与Partition" class="headerlink" title="Broker与Partition"></a>Broker与Partition</h3><p>这两个概念是ROS中没有的，Broker代理表示kafka服务器节点，partition是topic中的分区单元，一个broker可以划分为多个topic，一个topic可以划分为多个partition，partition就是一个消息队列中的队列。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue20210507200944439.png" alt="img"></p>
<h3 id="kafka怎么保证消息消费的顺序"><a href="#kafka怎么保证消息消费的顺序" class="headerlink" title="kafka怎么保证消息消费的顺序"></a>kafka怎么保证消息消费的顺序</h3><p>因为partition是一个队列，所以消费顺序是固定的❌</p>
<p>一个topic中可能有多个partition，消息被追加到partition中会计算偏移量，然后放入partition，如果有多个partition，并不能保证先存入的消息先被消费。</p>
<p>有两种方法：1、一个topic中只有一个partition，2、生产者将消息放入消息队列时指定key或者partition。</p>
<h3 id="kafka怎么保证消息不丢失"><a href="#kafka怎么保证消息不丢失" class="headerlink" title="kafka怎么保证消息不丢失"></a>kafka怎么保证消息不丢失</h3><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>若因为网络原因，导致生产者发送失败，则会重试，默认是重试10次，间隔时间0。</p>
<p><strong>如果重试失败，则失败后的数据怎么处理？</strong>消息会被送到死信队列中，对于死信队列的处理有两种方式：1、将死信队列设置一个专门的消息处理器，处理方法比如记录日志、发送警报和发送通知；2、重新消费这些消息。</p>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>当消费者拉取到partition的某个消息之后，消费者会自动提交offset，如果消费者刚拿到消息时突然挂掉了，则这条消息就丢失了。自动提交offset——&gt;手动提交，但是可能出现重复消费的问题。</p>
<h4 id="kafka-1"><a href="#kafka-1" class="headerlink" title="kafka"></a>kafka</h4><p>kafka为partition引入了多副本机制，多个副本之间会有个leader，除了leader其他称作follower，发送的消息会被发送到leader上，然后follower会从leader中拉取消息同步，如果leader挂掉的时候，还有follower没有同步，则丢失了消息。</p>
<p>可以设置acks &#x3D; all，这样所有follower都同步消息之后才会响应服务器。</p>
<h3 id="kafka如何保证消息不重复消费"><a href="#kafka如何保证消息不重复消费" class="headerlink" title="kafka如何保证消息不重复消费"></a>kafka如何保证消息不重复消费</h3><p>根本原因：消费者端已经消费的消息没有成功提交offset</p>
<p>解决方法：消费消息服务做幂等校验，比如Redis的set，MySQL的主键等天然的幂等功能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jiangduwang.github.io/2024/06/03/kafka/" data-id="clwyjx9fi0002jkul31k5dlxm" data-title="kafka八股" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-测试开发" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/10/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/" class="article-date">
  <time class="dt-published" datetime="2024-04-10T08:02:09.236Z" itemprop="datePublished">2024-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/10/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/">测试开发八股</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="测试的基本理论"><a href="#测试的基本理论" class="headerlink" title="测试的基本理论"></a>测试的基本理论</h2><h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><details>
<summary>展开查看</summary>

<p>又叫功能测试，功能测试在测试工作中占有比例最大。</p>
<p>测试人员不需要了解软件的内部结构，只关心输入和输出之间的关系是否符合预期。</p>
<p>无法保证软件代码内各主要路径都被覆盖到，导致测试不完全。</p>
</details>

<h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><details>
<summary>展开查看</summary>

<p>又叫结构测试</p>
<p>测试人员对软件的内部结构和工作原理有深入的了解，针对软件代码和路径进行测试。</p>
<p>软件代码改变，测试用例也需要改变。</p>
</details>

<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><details>
<summary>展开查看</summary>
描述输入实际值和预期输出行为或者结果的文档，同时也标识了测试过程结果与约束
</details>

<h3 id="测试用例的设计方法"><a href="#测试用例的设计方法" class="headerlink" title="测试用例的设计方法"></a>测试用例的设计方法</h3><details>
<summary>展开查看</summary>

<ul>
<li>等价类划分：将输入数据划分为若干等价类，认为每个等价类中的所有数据都会引起相同的处理结果。</li>
<li>边界值分析：测试边界值</li>
<li>决策表测试：针对多个输入条件的复杂逻辑，构建决策表，通过表格的形式明切输入条件极其对应的输出结果</li>
<li>随机测试：随机生成输入数据进行测试</li>
</ul>
</details>

<h2 id="如何理解测试开发中的开发"><a href="#如何理解测试开发中的开发" class="headerlink" title="如何理解测试开发中的开发"></a>如何理解测试开发中的开发</h2><details>
<summary>展开查看</summary>

<ol>
<li><strong>编写测试用例：</strong> 测试开发人员编写测试用例来验证软件系统的不同功能。这些测试用例可以是单元测试、集成测试、端到端测试等，覆盖不同层次和方面的功能和行为。</li>
<li><strong>编写自动化测试脚本：</strong> 测试开发人员使用编程语言（如Java、Python、JavaScript等）编写自动化测试脚本，用于执行测试用例并检查系统的响应和行为。这些脚本通常使用测试框架（如JUnit、TestNG、Selenium等）来组织和运行测试。</li>
<li><strong>开发测试工具和框架：</strong> 测试开发人员开发测试工具和框架，用于简化测试过程、提高测试效率和覆盖率。这些工具和框架可以包括测试数据生成工具、模拟器、Mock对象、测试管理系统等。</li>
<li><strong>维护测试代码：</strong> 随着软件系统的演变和变化，测试代码也需要不断更新和维护。测试开发人员负责确保测试代码的可靠性、稳定性和可维护性，以及及时更新测试代码以反映系统的变化。</li>
<li><strong>参与持续集成和持续部署：</strong> 测试开发人员参与持续集成和持续部署流程，确保每次代码提交或部署后都运行自动化测试，并及时发现和解决问题。</li>
</ol>
</details>

<h2 id="如何测试一个Java项目？"><a href="#如何测试一个Java项目？" class="headerlink" title="如何测试一个Java项目？"></a>如何测试一个Java项目？</h2><details>
<summary>展开查看</summary>

<ol>
<li><strong>单元测试：</strong> 编写单元测试来测试项目中的各个模块、类和方法。使用 JUnit 或 TestNG 等单元测试框架来编写测试用例，并确保覆盖尽可能多的代码路径和边界情况。</li>
<li><strong>集成测试：</strong> 编写集成测试来测试项目中不同模块之间的交互。这可以包括测试数据库访问、外部 API 调用、消息队列等。使用 JUnit、Mockito 等工具来模拟外部依赖，并编写集成测试用例。</li>
<li><strong>性能测试：</strong> 对项目进行性能测试，评估其在不同负载下的性能表现。使用 JMeter、Gatling 等性能测试工具来模拟大量用户请求，并监控系统的响应时间、吞吐量等指标。</li>
<li><strong>持续集成和持续部署：</strong> 将测试集成到持续集成和持续部署流程中，确保每次代码提交或部署后都运行测试，并及时发现和修复问题。</li>
</ol>
</details>

<h2 id="如果判断所写接口功能正常？"><a href="#如果判断所写接口功能正常？" class="headerlink" title="如果判断所写接口功能正常？"></a>如果判断所写接口功能正常？</h2><details>
<summary>展开查看</summary>

<ol>
<li><strong>功能测试：</strong> 确保接口按照预期工作。这包括发送各种有效和无效的输入数据，并验证接口的响应是否符合预期。例如，如果接口是一个登录接口，你可以测试使用正确的用户名和密码进行登录是否成功，以及使用错误的凭据时是否会得到适当的错误消息。</li>
<li><strong>性能测试：</strong> 检查接口的性能，包括响应时间、吞吐量等指标。确保接口在负载增加时仍然能够正常工作，并且性能不会严重下降。</li>
<li><strong>安全测试：</strong> 确保接口受到适当的安全保护，例如输入验证、防止SQL注入、XSS攻击等。</li>
<li><strong>兼容性测试：</strong> 确保接口在不同的浏览器、操作系统和设备上都能正常工作。</li>
</ol>
</details>

<h2 id="怎么构造无用测试用例？"><a href="#怎么构造无用测试用例？" class="headerlink" title="怎么构造无用测试用例？"></a>怎么构造无用测试用例？</h2><details>
<summary>展开查看</summary>

<ol>
<li><strong>随机数据：</strong> 使用随机生成的数据作为输入。这些数据可能不符合业务逻辑或实际情况，从而导致测试用例的无用性。</li>
<li><strong>非法输入：</strong> 提供完全不合法的输入数据。例如，如果一个字段要求输入数字，你可以提供字母字符或特殊字符。</li>
<li><strong>重复数据：</strong> 重复使用相同的数据进行测试，而不关注不同数据情况下的行为。这样做可能会错过一些潜在的问题。</li>
</ol>
</details>

<h2 id="如何感知线上项目出现问题"><a href="#如何感知线上项目出现问题" class="headerlink" title="如何感知线上项目出现问题"></a>如何感知线上项目出现问题</h2><details>
<summary>展开查看</summary>

<ol>
<li><strong>日志监控：</strong> 实时监控系统的日志以捕获异常情况和错误信息。通过设置适当的日志级别和使用日志聚合工具，可以帮助发现潜在的问题。</li>
<li><strong>性能监控：</strong> 监控系统的性能指标，如响应时间、吞吐量、CPU 使用率、内存使用率等。突然的性能下降可能是系统出现问题的迹象。</li>
<li><strong>自动化测试：</strong> 编写自动化测试用例，定期运行以确保系统的功能和性能符合预期。自动化测试可以在每次部署后运行，帮助发现新的问题。</li>
</ol>
</details>

<h2 id="小红书购物搜索框设计测试用例"><a href="#小红书购物搜索框设计测试用例" class="headerlink" title="小红书购物搜索框设计测试用例"></a>小红书购物搜索框设计测试用例</h2><details>
<summary>展开查看</summary>

<p><strong>测试用例名称：搜索框输入有效关键词</strong></p>
<ul>
<li>输入：在搜索框中输入有效的商品关键词，例如“连衣裙”。</li>
<li>操作：点击搜索按钮或按下回车键。</li>
<li>预期结果：搜索结果页面显示与输入关键词相关的商品列表。</li>
</ul>
<p><strong>测试用例名称：搜索框输入无效关键词</strong></p>
<ul>
<li>输入：在搜索框中输入无效的商品关键词，例如“@@@”。</li>
<li>操作：点击搜索按钮或按下回车键。</li>
<li>预期结果：搜索结果页面提示“未找到相关商品”。</li>
</ul>
<p><strong>测试用例名称：搜索框输入空关键词</strong></p>
<ul>
<li>输入：在搜索框中不输入任何内容。</li>
<li>操作：点击搜索按钮或按下回车键。</li>
<li>预期结果：搜索结果页面显示全部商品列表。</li>
</ul>
<p><strong>测试用例名称：搜索框联想功能</strong></p>
<ul>
<li>输入：在搜索框中输入部分关键词，例如“连衣”。</li>
<li>操作：等待几秒钟，观察搜索框下方是否出现联想词。</li>
<li>预期结果：搜索框下方显示与输入关键词相关的联想词列表。</li>
</ul>
<p><strong>测试用例名称：搜索框输入并选择联想词</strong></p>
<ul>
<li>输入：在搜索框中输入部分关键词，例如“连衣”。</li>
<li>操作：从联想词列表中选择一个词，例如“连衣裙”。</li>
<li>预期结果：搜索框中显示选择的联想词，并跳转到与该词相关的搜索结果页面。</li>
</ul>
<p><strong>测试用例名称：搜索框清空功能</strong></p>
<ul>
<li>输入：在搜索框中输入关键词，例如“连衣裙”。</li>
<li>操作：点击搜索框右侧的清空按钮。</li>
<li>预期结果：搜索框中的文本被清空，搜索框恢复为空状态。</li>
</ul>
</details>

<h2 id="登录设计测试样例"><a href="#登录设计测试样例" class="headerlink" title="登录设计测试样例"></a>登录设计测试样例</h2><details>
<summary>展开查看</summary>

<ol>
<li><strong>测试用例名称：输入有效的用户名和密码登录</strong><ul>
<li>输入：有效的用户名和密码。</li>
<li>操作：在登录页面输入用户名和密码，点击登录按钮。</li>
<li>预期结果：成功登录，跳转到用户的个人资料页面或首页。</li>
</ul>
</li>
<li><strong>测试用例名称：输入无效的用户名和密码登录</strong><ul>
<li>输入：无效的用户名和密码。</li>
<li>操作：在登录页面输入错误的用户名和密码，点击登录按钮。</li>
<li>预期结果：登录失败，提示用户名或密码错误的错误信息。</li>
</ul>
</li>
<li><strong>测试用例名称：输入不存在的用户名登录</strong><ul>
<li>输入：不存在的用户名和有效密码。</li>
<li>操作：在登录页面输入不存在的用户名和有效密码，点击登录按钮。</li>
<li>预期结果：登录失败，提示用户名不存在的错误信息。</li>
</ul>
</li>
<li><strong>测试用例名称：输入正确的用户名和空密码登录</strong><ul>
<li>输入：有效的用户名和空密码。</li>
<li>操作：在登录页面输入正确的用户名和空密码，点击登录按钮。</li>
<li>预期结果：登录失败，提示密码不能为空的错误信息。</li>
</ul>
</li>
<li><strong>测试用例名称：输入空用户名和正确密码登录</strong><ul>
<li>输入：空用户名和有效的密码。</li>
<li>操作：在登录页面输入空用户名和正确的密码，点击登录按钮。</li>
<li>预期结果：登录失败，提示用户名不能为空的错误信息。</li>
</ul>
</li>
<li><strong>测试用例名称：输入特殊字符的用户名和密码登录</strong><ul>
<li>输入：包含特殊字符的用户名和密码。</li>
<li>操作：在登录页面输入包含特殊字符的用户名和密码，点击登录按钮。</li>
<li>预期结果：登录失败，提示用户名或密码格式不正确的错误信息。</li>
</ul>
</li>
<li><strong>测试用例名称：记住登录状态</strong><ul>
<li>输入：有效的用户名和密码。</li>
<li>操作：在登录页面勾选“记住我”选项后登录。</li>
<li>预期结果：成功登录后，关闭浏览器再次打开时，应自动保持登录状态，无需重新输入用户名和密码。</li>
</ul>
</li>
<li><strong>测试用例名称：登录页链接验证</strong><ul>
<li>输入：无。</li>
<li>操作：检查登录页面上的链接。</li>
<li>预期结果：登录页面应包含“忘记密码”、“注册账号”等相关链接，确保用户可以方便地进行其他操作。</li>
</ul>
</li>
<li><strong>测试用例名称：跳转到登录页面</strong><ul>
<li>输入：未登录状态。</li>
<li>操作：尝试访问需要登录权限的页面。</li>
<li>预期结果：跳转到登录页面，并在登录成功后自动跳回原页面。</li>
</ul>
</li>
<li><strong>测试用例名称：登录界面的响应速度</strong><ul>
<li>输入：无。</li>
<li>操作：在不同网络环境下打开登录页面。</li>
<li>预期结果：登录页面应该在合理的时间内加载完成，不应该出现过长的加载时间。</li>
</ul>
</li>
</ol>
</details>

<h2 id="微信发送文件的测试用例"><a href="#微信发送文件的测试用例" class="headerlink" title="微信发送文件的测试用例"></a>微信发送文件的测试用例</h2><details>
<summary>展开查看</summary>

<ul>
<li><p>功能测试</p>
<ul>
<li>正常发送文件</li>
<li>发送支持的文件类型</li>
</ul>
</li>
<li><p>边界值测试</p>
<ul>
<li>发送最大允许大小的文件</li>
<li>发送超过最大允许大小的文件</li>
</ul>
</li>
<li><p>异常情况测试</p>
<ul>
<li>发送空文件</li>
<li>发送损坏文件</li>
<li>网络中断后重新发送</li>
</ul>
</li>
<li><p>性能测试</p>
<ul>
<li>同时发送多个文件</li>
<li>选择一个接近最大允许大小的文件</li>
</ul>
</li>
<li><p>用户体验测试</p>
<ul>
<li>发送文件时的用户提示</li>
<li>文件发送记录</li>
</ul>
</li>
<li><p>安全性测试</p>
<ul>
<li>发送包含敏感信息的文件</li>
<li>病毒文件检测</li>
</ul>
</li>
<li><p>跨平台测试</p>
</li>
</ul>
</details>

<h2 id="微信发送红包的测试用例"><a href="#微信发送红包的测试用例" class="headerlink" title="微信发送红包的测试用例"></a>微信发送红包的测试用例</h2><details>
<summary>展开查看</summary>

<ul>
<li><p>功能测试</p>
<ul>
<li>正常发送红包</li>
<li>发送拼手气红包</li>
<li>发送定向红包</li>
</ul>
</li>
<li><p>边界值测试</p>
<ul>
<li>发送最低和最高金额的红包</li>
<li>发送超过最高金额的红包</li>
</ul>
</li>
<li><p>异常情况测试</p>
<ul>
<li>余额不足时发送红包</li>
<li>网络中断后重新发送</li>
<li>取消发送红包</li>
</ul>
</li>
<li><p>安全性测试</p>
<ul>
<li>多测领取红包</li>
<li>红包过期</li>
<li>未实名验证用户发送红包</li>
<li>单方删除好友后发送红包</li>
</ul>
</li>
<li><p>用户体验测试</p>
</li>
<li><p>跨平台测试</p>
</li>
<li><p>性能测试</p>
<ul>
<li>高频发送红包</li>
<li>大规模红包领取（拼手气红包）</li>
</ul>
</li>
</ul>
</details>

<h3 id="电影订票功能的测试样例"><a href="#电影订票功能的测试样例" class="headerlink" title="电影订票功能的测试样例"></a>电影订票功能的测试样例</h3><ul>
<li><p>功能测试</p>
<ul>
<li>检查电影本身的信息和电影院（不同的电影院）、场次（不同的场次）、座位信息（已售出和可售状态）是否显示正确</li>
<li>验证不同支付方式是否可用</li>
<li>验证电子票是否包含必要信息、是否能通过扫描进入影院</li>
</ul>
</li>
<li><p>边界和异常情况测试</p>
<ul>
<li>无效的账户或者账户余额不足进行支付</li>
<li>用户选择座位但未完成支付，座位在一定时间后能否自动释放</li>
</ul>
</li>
<li><p>性能测试</p>
<ul>
<li>系统负载测试：高并发访问</li>
<li>正常负载和高负载下的响应时间是否正常</li>
</ul>
</li>
<li><p>兼容性测试</p>
</li>
</ul>
<h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><details>
<summary>展开查看</summary>

<p>以人为驱动的测试行为转化为机器执行的一种过程</p>
<p>自动化测试包括UI测试、接口测试和单元测试</p>
<p><strong>Selenium</strong>——UI自动化测试工具，工作原理：</p>
<ol>
<li>开发人员编写自动化脚本代码（测试代码）</li>
<li>测试代码通过Web驱动程序（如ChromeDriver、GeckoDriver等）与所选浏览器建立通信</li>
<li>Web驱动程序将命令发送给浏览器，并接收来自浏览器的响应。</li>
<li>浏览器执行接收到的命令，例如导航至指定URL、查找和操作页面上的元素等。</li>
<li>浏览器将执行结果返回给Web驱动程序。</li>
<li>Web驱动程序将结果传递给测试代码，以便进行进一步的处理和验证。</li>
</ol>
<p><img src="https://developer.qcloudimg.com/http-save/yehe-10496291/a66e29500026a19ea096b11bf8bae1f8.png" alt="img"></p>
</details>

<h2 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h2><details>
<summary>展开查看</summary>

<ol>
<li><strong>JUnit</strong>：JUnit是Java中最流行的单元测试框架之一，用于编写和运行单元测试。它提供了一组注解和断言方法，使得编写测试用例变得简单易懂。</li>
<li><strong>TestNG</strong>：TestNG是另一个流行的Java测试框架，提供了比JUnit更丰富的功能，例如参数化测试、测试组、依赖测试等。它也可以用于编写单元测试和集成测试。</li>
<li><strong>Selenium</strong>：Selenium是用于自动化Web应用程序测试的工具，它支持多种浏览器，并提供了Java API，使得测试脚本的编写和执行变得简单。Selenium可以用于执行功能测试、回归测试等。</li>
<li><strong>JMeter</strong>：JMeter是一个用于性能测试的工具，它可以模拟大量用户并测量应用程序的性能和稳定性。JMeter也可以用于功能测试和接口测试。</li>
</ol>
</details>

<h2 id="项目中的实际测试经验"><a href="#项目中的实际测试经验" class="headerlink" title="项目中的实际测试经验"></a>项目中的实际测试经验</h2><p>周期性心跳包阻塞<br>从100ms阻塞到700ms<br>排查网络：网络延时，无线转有线<br>软件层数据问题，接收数据排查，校验和错误或长度错误导致未执行<br>发送端的问题，模块间冲突，删除模块依次测试，看问题是否解决<br>只剩下udp后还存在问题，底层问题，写日志，看日志是否阻塞<br>top查看cpu，是否异常占用，cpu调度<br>system-journaled每次阻塞时cpu占用高，这个是管理Linux日志的线程，查内核日志<br>有频繁写入写出，硬件接口连接问题，日志几十微妙的速度写，导致阻塞。<br>最终禁用该服务</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jiangduwang.github.io/2024/04/10/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/" data-id="clutj1iws0001l8ul99efduqk" data-title="测试开发八股" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-简历八股内容" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/02/%E7%AE%80%E5%8E%86%E5%85%AB%E8%82%A1%E5%86%85%E5%AE%B9/" class="article-date">
  <time class="dt-published" datetime="2024-04-02T10:28:05.019Z" itemprop="datePublished">2024-04-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/02/%E7%AE%80%E5%8E%86%E5%85%AB%E8%82%A1%E5%86%85%E5%AE%B9/">面试八股内容</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>面试官下午好，我叫顾涛，是一名南京理工大学的硕士研究生，专业是计算机科学与技术。在校期间，我参与了多个研究所的实习项目，主要是参与巡逻无人车车内软件的开发；然后Java是参与完成了MTR课表小程序，主要是帮南理工的同学们快捷查询课表、成绩等教务信息，以及实现一个校内学生交流的平台。</p>
<h2 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h2><h3 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h3><h4 id="HashMap-与-ConcurrentHashMap-的实现原理是怎样的？ConcurrentHashMap-是如何保证线程安全的？"><a href="#HashMap-与-ConcurrentHashMap-的实现原理是怎样的？ConcurrentHashMap-是如何保证线程安全的？" class="headerlink" title="HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？"></a>HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？</h4><p>（hashmap1.7和1.8的区别）</p>
<details>
<summary>展开查看</summary>

<ul>
<li>hashmap1.8之前数组和链表结合在一起使用（拉链法），哈希冲突将元素加入到链表中，1.7采用的是头插法。1.8及以后，默认长度为16，当负载因子大于0.75时会扩充数组（每次扩容一倍，移位操作，效率比较高），链表长度大于8，如果数组长度不大于64会扩充数组，否则会转化为红黑树，1.8采用的是尾插法。<strong>每次扩充都会rehash</strong>。</li>
<li>concurrenthashmap在1.7由多个segment组成，一个segment相当于一个hashmap，每一个segment用一个锁，segment最大长度16；1.8之后减少了悲观锁的使用，会先尝试自旋+CAS方式加入元素，尝试多次不成功才通过synchronized锁。底层也是由数组+链表变为数组+红黑树。</li>
</ul>
</details>

<h4 id="为什么1-8的哈希表加入元素改用尾插法"><a href="#为什么1-8的哈希表加入元素改用尾插法" class="headerlink" title="为什么1.8的哈希表加入元素改用尾插法"></a>为什么1.8的哈希表加入元素改用尾插法</h4><details>
<summary>展开查看</summary>

<p>1.8之前，hashmap采用的是头插法，是考虑到新插入的数据可能作为热点数据使用，放在头部可以减少查找时间；</p>
<p>1.8之后采用的是尾插法，为的是防止在多线程环境下出现<strong>环化</strong>。</p>
<p>多线程下头插法出现环化的问题：假设两个线程分别都插入一个数据A和B，前一个线程在准备插入时时间片用完，第二个线程进行扩容，因为是头插法，因此数据顺序是BA，但此时第一个线程的cur指针指向A，next指针指向B，它会先移动A，然后cur指针移向B，再插入B，由于第二个线程的next的指针的下一个next指针还是指向A，第一个线程还会再插入一次A，这样ABA，出现环化。</p>
</details>

<h4 id="简述-ArrayList-与-LinkedList-的底层实现以及常见操作的时间复杂度"><a href="#简述-ArrayList-与-LinkedList-的底层实现以及常见操作的时间复杂度" class="headerlink" title="简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度"></a>简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度</h4><details>
<summary>展开查看</summary>

<ul>
<li>arraylist底层实现就是一个初始容量10构造的空数组，尾部插入和删除时间复杂度O(1)，其余操作都是O(n)</li>
<li>linkedlist底层实现是一个双向链表，首尾插入和删除时间复杂度O(1)，其余操作都是O(n)</li>
</ul>
</details>

<h4 id="hashcode和equals方法的联系"><a href="#hashcode和equals方法的联系" class="headerlink" title="hashcode和equals方法的联系"></a>hashcode和equals方法的联系</h4><details>
<summary>展开查看</summary>

<p>当两个对象的哈希码相同且equals为true时，表明两个对象相等。</p>
<p>重写equals方法必须要重写hashcode方法，避免hashcode不相等而equals相等的情况。</p>
</details>

<h4 id="和equals有什么区别"><a href="#和equals有什么区别" class="headerlink" title="&#x3D;&#x3D;和equals有什么区别"></a>&#x3D;&#x3D;和equals有什么区别</h4><details>
<summary>展开查看</summary>

<p>&#x3D;&#x3D;对比非引用变量直接比值，引用变量比较地址值</p>
<p>原object的equals对比两个对象的地址值，经过重写后基本都对比真正的值，比如string</p>
</details>

<h4 id="浅拷贝、深拷贝、引用拷贝"><a href="#浅拷贝、深拷贝、引用拷贝" class="headerlink" title="浅拷贝、深拷贝、引用拷贝"></a>浅拷贝、深拷贝、引用拷贝</h4><details>
<summary>展开查看</summary>

<ul>
<li>浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li>
<li>深拷贝完全复制整个对象，包括这个对象包含的内部对象</li>
<li>引用拷贝是两个不同的引用指向同一个对象</li>
</ul>
</details>

<h4 id="什么是重写和重载"><a href="#什么是重写和重载" class="headerlink" title="什么是重写和重载"></a>什么是重写和重载</h4><details>
<summary>展开查看</summary>

<p>重载是指方法名相同，返回值、参数列表都可以不相同，比如构造函数；</p>
<p>重写是子类对父类已有的方法进行覆盖，参数列表必须相同。</p>
</details>

<h4 id="java中final的作用"><a href="#java中final的作用" class="headerlink" title="java中final的作用"></a>java中final的作用</h4><details>
<summary>展开查看</summary>

<p>对于变量，表明该变量的值不能被修改；对于方法，表示子类不能重写final修饰的父类的方法；对于类，则该类不能被继承。</p>
</details>

<h4 id="hashset实现原理"><a href="#hashset实现原理" class="headerlink" title="hashset实现原理"></a>hashset实现原理</h4><details>
<summary>展开查看</summary>

<p>底层是hashmap，调用add实际上就是调用hashmap的put方法</p>
</details>

<h4 id="装饰者模式和适配器模式"><a href="#装饰者模式和适配器模式" class="headerlink" title="装饰者模式和适配器模式"></a>装饰者模式和适配器模式</h4><details>
<summary>展开查看</summary>

<ul>
<li>装饰者模式是指在不改变原有功能的前提下增强功能，有点类似AOP，比如FlieInputStream和InputStream类</li>
<li>适配器模式是指让接口不兼容而不能交互的类可以一起工作，比如InputStreamReader可以将字节流转为字符流</li>
</ul>
</details>

<h4 id="BIO-NIO-AIO"><a href="#BIO-NIO-AIO" class="headerlink" title="BIO  NIO AIO"></a>BIO  NIO AIO</h4><details>
<summary>展开查看</summary>

<p>BIO<strong>阻塞同步IO模型</strong></p>
<p>NIO分为两种，一种会一直<strong>轮询</strong>直到调用，一种是<strong>多路复用</strong>，先发起select调用，询问是否准备就绪了，准备就绪了就会调用</p>
<p>AIO <strong>异步IO模型</strong></p>
</details>

<h4 id="java出现OOM的情况"><a href="#java出现OOM的情况" class="headerlink" title="java出现OOM的情况"></a>java出现OOM的情况</h4><details>
<summary>展开查看</summary>

<ul>
<li>创建了太多对象</li>
<li>创建了太大的对象，比如数组开的太大</li>
<li>创建了大量的字符串常量</li>
</ul>
</details>

<h4 id="java设计模式"><a href="#java设计模式" class="headerlink" title="java设计模式"></a>java设计模式</h4><details>
<summary>展开查看</summary>

<ul>
<li>单例模式</li>
<li>工厂模式</li>
<li>适配器模式</li>
<li>代理模式</li>
</ul>
</details>

<h4 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h4><details>
<summary>展开查看</summary>

<ul>
<li>接口更侧重于定义规范和契约,而抽象类更侧重于代码复用和实现共享功能。</li>
<li>接口类中不能包含具体的方法实现，抽象类中可以包含具体的方法实现；</li>
<li>只能继承一个抽象类，可以实现多个接口</li>
</ul>
</details>

<h4 id="java对象的组成部分"><a href="#java对象的组成部分" class="headerlink" title="java对象的组成部分"></a>java对象的组成部分</h4><details>
<summary>展开查看</summary>

<p>对象都由对象头、对象的实例数据区和对齐填充字节这三部分组成。</p>
<p>对象头包含对象和锁的信息、指向类的指针和数组长度；</p>
<p>对齐填充字节：java对象所占空间应该是8bit倍数，将对象大小补充为8bit的倍数。</p>
</details>

<h4 id="java从源代码到可执行程序"><a href="#java从源代码到可执行程序" class="headerlink" title="java从源代码到可执行程序"></a>java从源代码到可执行程序</h4><details>
<summary>展开查看</summary>

<p>源代码.java文件，经过javac编译器生成字节码.class文件，再经过JVM中的解释器生成机器码。（先编译，再解释）</p>
</details>

<h3 id="java的内存区域与垃圾回收机制"><a href="#java的内存区域与垃圾回收机制" class="headerlink" title="java的内存区域与垃圾回收机制"></a>java的内存区域与垃圾回收机制</h3><h4 id="Java-中垃圾回收机制中如何判断对象需要回收？常见的-GC-回收算法有哪些？"><a href="#Java-中垃圾回收机制中如何判断对象需要回收？常见的-GC-回收算法有哪些？" class="headerlink" title="Java 中垃圾回收机制中如何判断对象需要回收？常见的 GC 回收算法有哪些？"></a>Java 中垃圾回收机制中如何判断对象需要回收？常见的 GC 回收算法有哪些？</h4><details>
<summary>展开查看</summary>

<ul>
<li>有两种方法：一种是<strong>引用计数法</strong>，计算每个对象的被引用次数，若为0，则需要回收，但有可能需要循环引用的情况；还有一种<strong>可达性分析</strong>，从gc根节点向下搜索，若不可达，则回收这个对象。</li>
<li>标记-清除、复制、标记-整理，新生代一般使用复制算法（应用：两个survivor区），老生代标记-清除</li>
</ul>
</details>

<h4 id="JVM内存分类"><a href="#JVM内存分类" class="headerlink" title="JVM内存分类"></a>JVM内存分类</h4><details>
<summary>展开查看</summary>

<ul>
<li>堆内存：几乎所有对象实例和<strong>字符串常量池</strong>都会放在堆上，同时堆也是gc管理的主要区域，也叫gc堆</li>
<li>栈内存：主要存临时变量和对象引用</li>
<li>本地内存：包含元空间（永久代 ），元空间就是方法区的实现，存放了<strong>常量池</strong>。</li>
</ul>
</details>

<h4 id="Java-类的加载流程是怎样的？什么是双亲委派机制？"><a href="#Java-类的加载流程是怎样的？什么是双亲委派机制？" class="headerlink" title="Java 类的加载流程是怎样的？什么是双亲委派机制？"></a>Java 类的加载流程是怎样的？什么是双亲委派机制？</h4><details>
<summary>展开查看</summary>

<ul>
<li>加载——链接（验证——准备——解析）——初始化</li>
<li>类加载器实例在亲自查找类和资源之前，会将这个任务委托给父类加载器。</li>
</ul>
<p><strong>避免类重复加载：</strong> 双亲委派模式可以避免同一个类被重复加载到 JVM 中。当父加载器已经加载了一个类时，子加载器不会再次加载该类，而是直接使用父加载器加载的类。这样可以节省内存空间，并提高类加载的效率。</p>
<p>类加载器：</p>
<ul>
<li>启动类加载器：所有类加载器的父加载器，加载java的核心标准库</li>
<li>扩展类加载器：加载java的扩展类库</li>
<li>系统类加载器：加载classpath下的类和jar包</li>
<li>自定义加载器</li>
</ul>
</details>

<h4 id="简述-CMS-与-G1-机制的区别"><a href="#简述-CMS-与-G1-机制的区别" class="headerlink" title="简述 CMS 与 G1 机制的区别"></a>简述 CMS 与 G1 机制的区别</h4><details>
<summary>展开查看</summary>

<p>cms一款并发垃圾收集器，实现了让<strong>垃圾收集线程</strong>和<strong>用户线程</strong>同时工作。</p>
<ul>
<li>CMS主要设计目的是<strong>减少垃圾回收的停顿时间</strong>，G1是提供<strong>可预测的停顿时间</strong>，同时兼顾吞吐量和停顿时间。</li>
<li>CMS通过并发标记和并发清除来收集垃圾对象，G1通过<strong>划分内存区域</strong>和<strong>优先级排序</strong>，再通过并发标记来实现目标。</li>
</ul>
</details>

<h4 id="垃圾回收分为哪几个区，JVM是如何进行垃圾回收的"><a href="#垃圾回收分为哪几个区，JVM是如何进行垃圾回收的" class="headerlink" title="垃圾回收分为哪几个区，JVM是如何进行垃圾回收的"></a>垃圾回收分为哪几个区，JVM是如何进行垃圾回收的</h4><details>
<summary>展开查看</summary>

<p>年轻代：eden区，两个survivor区</p>
<p>老年代，永生代（元空间，方法区的实现）</p>
<p>当eden区满了之后，会触发minor GC，将eden区和一个s区存活的对象复制到另一个空的s区中，对象在多次minor GC下存活，年龄到一定阈值，晋升到老年代；</p>
<p>老年代满了或者系统调用System.gc()，触发major gc放入永久代</p>
</details>

<h4 id="新生代设计两个survivor区的目的是什么"><a href="#新生代设计两个survivor区的目的是什么" class="headerlink" title="新生代设计两个survivor区的目的是什么"></a>新生代设计两个survivor区的目的是什么</h4><details>
<summary>展开查看</summary>

<p>如果只有一个survivor区的话，由于survivor区中也有死亡的对象，这样survivor区就出现了内存碎片，然而survivor区还有很多对象年龄还没有到，不能清理survivor区中的对象到老年代中。</p>
<p>有两个survivor区的话，相当于标记-复制算法，当Eden区满了之后会触发一次minor gc，将Eden区和s0区中存活的对象都写入s1区中，为了避免不断地在两个s区之间复制对象，此时将空的s0区作为原来的s1区使用。</p>
<p><strong>有效避免内存碎片化</strong></p>
</details>

<h3 id="java并发编程"><a href="#java并发编程" class="headerlink" title="java并发编程"></a>java并发编程</h3><h4 id="Synchronized-关键字底层是如何实现的？它与-Lock-相比优缺点分别是什么？"><a href="#Synchronized-关键字底层是如何实现的？它与-Lock-相比优缺点分别是什么？" class="headerlink" title="Synchronized 关键字底层是如何实现的？它与 Lock 相比优缺点分别是什么？"></a>Synchronized 关键字底层是如何实现的？它与 Lock 相比优缺点分别是什么？</h4><details>
<summary>展开查看</summary>

<ul>
<li>底层是通过同步代码块实现，1个monitorenter指令指向同步代码块的开始位置，两个monitorexit指向结束位置</li>
<li>优点：使用简单；synchronized依赖于jvm，可以得到jvm层面的优化； 缺点：没有lock灵活，功能没有lock丰富。</li>
</ul>
</details>

<h4 id="Java-的线程有哪些状态，转换关系是怎么样的？"><a href="#Java-的线程有哪些状态，转换关系是怎么样的？" class="headerlink" title="Java 的线程有哪些状态，转换关系是怎么样的？"></a>Java 的线程有哪些状态，转换关系是怎么样的？</h4><details>
<summary>展开查看</summary>

<p>新建、运行、等待、阻塞、终止。</p>
<p>线程创建之后，调用start方法线程等待运行；调用wait方法，等待某些条件、资源的满足；<strong>悲观锁阻塞，等待锁释放</strong>；线程完成或异常终止。</p>
</details>

<h4 id="JMM-中内存模型是怎样的？什么是指令序列重排序？"><a href="#JMM-中内存模型是怎样的？什么是指令序列重排序？" class="headerlink" title="JMM 中内存模型是怎样的？什么是指令序列重排序？"></a>JMM 中内存模型是怎样的？什么是指令序列重排序？</h4><details>
<summary>展开查看</summary>

<ul>
<li>内存模型是Java中多线程并发访问共享内存的规则和保证，具体工作方式是线程的共享变量必须存储在主内存中，每个线程中都有一个私有的本地内存，线程对共享变量的修改都是现在私有本地内存中修改，再更新到主内存中。</li>
<li>在不改变程序执行结果的前提下，JVM会重新调整指令的执行顺序以提升执行效率。</li>
</ul>
</details>

<h4 id="volatile-关键字解决了什么问题，它的实现原理是什么？"><a href="#volatile-关键字解决了什么问题，它的实现原理是什么？" class="headerlink" title="volatile 关键字解决了什么问题，它的实现原理是什么？"></a>volatile 关键字解决了什么问题，它的实现原理是什么？</h4><details>
<summary>展开查看</summary>

<p>保证了变量的可见性，每次修改volatile修饰的变量都需要进入主存中读取；可以防止JVM指令重排序（通过内存屏障实现）。</p>
</details>

<h4 id="简述-CAS-原理，什么是-ABA-问题，怎么解决？"><a href="#简述-CAS-原理，什么是-ABA-问题，怎么解决？" class="headerlink" title="简述 CAS 原理，什么是 ABA 问题，怎么解决？"></a>简述 CAS 原理，什么是 ABA 问题，怎么解决？</h4><details>
<summary>展开查看</summary>

<ul>
<li>乐观锁compare and swap      当更新的值和预期值相等时，对数据进行更新</li>
<li>aba问题是在比对更新值和预期值，中间经历了几次更新，但是最终的更新值还是等于预期值。   解决：CAS+版本号机制或时间戳</li>
</ul>
</details>

<h4 id="CAS除了ABA问题还有哪些问题？"><a href="#CAS除了ABA问题还有哪些问题？" class="headerlink" title="CAS除了ABA问题还有哪些问题？"></a>CAS除了ABA问题还有哪些问题？</h4><details>
<summary>展开查看</summary>

<ul>
<li>循环时间长开销大  CAS通过自旋操作不断重试</li>
<li>只能保证一个共享变量的原子操作   CAS只对一个共享变量有效。</li>
</ul>
</details>

<h4 id="线程池是如何实现的？简述线程池的任务策略"><a href="#线程池是如何实现的？简述线程池的任务策略" class="headerlink" title="线程池是如何实现的？简述线程池的任务策略"></a>线程池是如何实现的？简述线程池的任务策略</h4><details>
<summary>展开查看</summary>

<p>核心参数：核心线程数、最大线程数、线程任务队列，临时线程存活时间</p>
<ul>
<li>通过ThreadPoolExecutor构造函数可以创建多种类型的线程池，包括固定线程线程池、单线程线程池、cache线程池等</li>
<li>任务策略即饱和策略，默认策略是抛出异常拒绝新来的任务；或者把任务退回给调用者线程，让调用者线程来执行这个任务；或者丢弃掉最早未处理的任务</li>
</ul>
</details>

<h4 id="ThreadLocal-实现原理是什么？"><a href="#ThreadLocal-实现原理是什么？" class="headerlink" title="ThreadLocal 实现原理是什么？"></a>ThreadLocal 实现原理是什么？</h4><details>
<summary>展开查看</summary>

<p>threadlocal会保存变量的本地副本，使其独属于这个线程。本质上是一个threadlocalmap，键为threadlocal对象（弱引用），值为副本的值（强引用），调用threadlocal的put和get方法本质上就是调用threadlocalmap的put和get方法</p>
</details>

<h4 id="Java锁升级机制"><a href="#Java锁升级机制" class="headerlink" title="Java锁升级机制"></a>Java锁升级机制</h4><details>
<summary>展开查看</summary>

<p>锁升级是从偏向锁到轻量级锁，再到重量级锁的过程，由jvm运行时决定。</p>
<p>偏向锁会偏向第一次被加锁的对象，轻量级锁指有另一个线程尝试获取锁，偏向锁会升级成轻量级锁，会通过自旋等待获取锁；当自旋等待获取不到锁，会升级到重量级锁，重量级锁就是排他锁。</p>
<p>自旋：线程等待的方式，不会让线程进入阻塞状态，不断重试直至满足条件</p>
</details>

<h4 id="什么是公平锁？什么是非公平锁？"><a href="#什么是公平锁？什么是非公平锁？" class="headerlink" title="什么是公平锁？什么是非公平锁？"></a>什么是公平锁？什么是非公平锁？</h4><details>
<summary>展开查看</summary>

<p>公平锁表示获取锁的顺序按照请求的顺序来分配，FIFO</p>
<p>非公平锁不一定按照请求的顺序。</p>
<p>synchronized非公平锁，reentrantlock默认非公平锁，可以设置公平锁（基于JDK，通过构造函数设置）。</p>
</details>

<h4 id="可重入锁的实现原理"><a href="#可重入锁的实现原理" class="headerlink" title="可重入锁的实现原理"></a>可重入锁的实现原理</h4><details>
<summary>展开查看</summary>

<p>为每个锁维护一个<strong>拥有者线程标识</strong>和<strong>计数器</strong>，在加锁和解锁操作时对计数器进行递增和递减，并通过并发控制确保线程对锁状态的访问是安全的。</p>
<p>如ReentrantLock，在内部维护了一个锁状态变量和一个等待队列，等待队列会阻塞等待获取锁的线程。在获取锁的时候，会判断当前锁状态变量是否为0，如果为0，则获取到锁，且锁状态变量+1，这时其他锁线程无法获取到锁，当获取锁的同一个线程再次获取锁时，则锁状态变量会再加一。当锁状态变量变为0才会真正释放锁。</p>
</details>

<h4 id="父子线程的threadlocal能共享吗？"><a href="#父子线程的threadlocal能共享吗？" class="headerlink" title="父子线程的threadlocal能共享吗？"></a>父子线程的threadlocal能共享吗？</h4><details>
<summary>展开查看</summary>

<p>异步场景下无法给子线程共享父线程中创建的线程副本数据；</p>
<p>JDK提供了<code>InheritableThreadLocal</code>类，可以让子线程共享父线程的数据。</p>
</details>

<h4 id="线程池的工作流程"><a href="#线程池的工作流程" class="headerlink" title="线程池的工作流程"></a>线程池的工作流程</h4><details>
<summary>展开查看</summary>

<ul>
<li>线程数小于核心线程数：线程池创建一个新的工作线程执行任务</li>
<li>线程数大于等于核心线程数：任务进入到任务队列</li>
<li>任务队列已满：当前线程数小于最大线程数，会创建工作线程处理任务队列中的任务</li>
<li>任务队列已满且已达到最大线程数：启用拒绝策略，默认是抛出异常拒绝新来的任务，或者将任务退回给调用者线程执行，或者抛弃最早未执行的任务。</li>
</ul>
</details>

<h4 id="对字符串上锁"><a href="#对字符串上锁" class="headerlink" title="对字符串上锁"></a>对字符串上锁</h4><p>问：现在有两个字符串常量，值都是一样的，现在我对这两个常量都上锁，锁之间会互相影响吗？</p>
<summary>展开查看</summary>

<p>答：两个字符串字面值相同，则它们引用的是相同的字符串对象（字符串常量池），进行锁操作的话会相互影响，多个线程会共享同一个锁，当一个线程在持有锁的时候，其他线程需要等待该锁释放才能获取到。</p>
</details>

<h3 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h3><h4 id="常见的面向对象设计的设计模式"><a href="#常见的面向对象设计的设计模式" class="headerlink" title="常见的面向对象设计的设计模式"></a>常见的面向对象设计的设计模式</h4><details>
<summary>展开查看</summary>

<p>工厂模式和单例模式，工厂模式通过封装对象的创建过程降低耦合度。单例模式适合只需要创建一次的对象，比如线程池，日志对象。</p>
<p><strong>单例模式的实现</strong>   私有构造函数，通过volatile关键字定义单例，避免指令重排序，采用双重校验锁保证单例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> singleton a;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">singleton</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="literal">null</span>)&#123;</span><br><span class="line">            a = <span class="keyword">new</span> <span class="title class_">singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 饿汉式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">singleton2</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> singleton2 a;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">singleton2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> singleton2 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双重锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//注意这里是对类对象加锁，不是对单例对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</details>

<h4 id="spring中的单例bean是线程安全的吗"><a href="#spring中的单例bean是线程安全的吗" class="headerlink" title="spring中的单例bean是线程安全的吗"></a>spring中的单例bean是线程安全的吗</h4><details>
<summary>展开查看</summary>

<p>spring中的bean默认是单例模式，可以修改为多例模式。</p>
<p><strong>spring中的单例bean不是线程安全的，</strong>一般情况下spring的bean都是注入无状态的对象，没有线程安全问题；但是如果在bean中定义了可修改的变量，线程就不安全了，要靠多例模式或者加锁来实现线程安全。</p>
<p>线程不安全的例子：项目中设置一个计数器服务，创建一个bean来记录。</p>
</details>

<h4 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h4><details>
<summary>展开查看</summary>

<p>在运行时可以分析类以及执行类中的方法，通过反射可以获取类中的所有属性和方法</p>
</details>

<h4 id="IOC和AOP"><a href="#IOC和AOP" class="headerlink" title="IOC和AOP"></a>IOC和AOP</h4><details>
<summary>展开查看</summary>

<ul>
<li>IOC控制反转，对象的创建和调用控制交给容器来实现，具体是依赖注入。通过<strong>工厂模式</strong>负责对象的创建和管理。</li>
<li>AOP面向切面编程：代理模式（通过反射实现），通过代理对象实现对目标方法的增强。静态代理，定义一个真实类和一个代理类实现接口，将真实对象注入到代理类中；动态代理分为jdk动态代理和CGLIB动态代理，jdk动态代理只能代理实现了接口的类或直接代理接口，cglib可以代理未实现任何接口的类，它生成一个被代理类的子类来拦截被代理类的方法调用</li>
</ul>
<p><strong>AOP的应用</strong>  记录操作日志、Spring中内置的事务处理（<strong>声明式事务管理</strong>    通过环绕通知捕捉异常实现事务的执行或者回滚）</p>
</details>

<h4 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h4><details>
<summary>展开查看</summary>

<p>BeanDefinition（获取bean的定义信息）——&gt; 对象的创建（构造函数，创建空对象） ——&gt;对象方法的创建（依赖注入：注入属性和值）</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240325145435343.png" alt="image-20240325145435343"></p>
</details>

<h4 id="spring如何解决循环依赖的问题"><a href="#spring如何解决循环依赖的问题" class="headerlink" title="spring如何解决循环依赖的问题"></a>spring如何解决循环依赖的问题</h4><details>
<summary>展开查看</summary>

<p>Spring通过使用三级缓存来解决循环依赖问题。<strong>bean的创建分为两步：对象的实例化和对象属性的实例化</strong>  未对象属性实例化的对象称为半成品对象</p>
<p>一级缓存存储已完全初始化的对象，二级缓存存储半成品对象，三级缓存只是对象的创建委托。</p>
<p>spring中的循环依赖对象的创建过程：</p>
<ol>
<li>A创建过程中依赖B，则A进入三级缓存中，再去实例化B</li>
<li>B创建过程中依赖A，则查找缓存中是否有A，发现三级缓存中有A，则将A放入二级缓存中，并删除三级缓存中的A。</li>
<li>B创建完成，将B放入一级缓存中，此时A还是半成品对象，然后继续创建A，A依赖B，这时去查缓存，发现B在一级缓存中，直接取B完成创建，最后完成创建A，将A放入一级缓存中。</li>
</ol>
</details>

<h4 id="springMVC的执行流程"><a href="#springMVC的执行流程" class="headerlink" title="springMVC的执行流程"></a>springMVC的执行流程</h4><details>
<summary>展开查看</summary>

<ol>
<li>用户发出HTTP请求到嵌入式服务器（tomcat）,嵌入式服务器可以监听指定的端口（8080）</li>
<li>嵌入式服务器会将请求交给spring的核心组件DispatcherServlet（前端控制器）</li>
<li>前端控制器收到请求调用处理器映射器</li>
<li>处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器，再一起返回给前端控制器；</li>
<li>前端控制器调用处理器适配器，处理器适配器经过适配调用具体的处理器</li>
<li>在方法上添加了@ResponseBody，通过HttpMessageConverter来返回结果转换为JSON并响应。</li>
<li>先响应到嵌入式服务器，再响应到客户端</li>
</ol>
</details>

<h4 id="springboot自动配置原理"><a href="#springboot自动配置原理" class="headerlink" title="springboot自动配置原理"></a>springboot自动配置原理</h4><details>
<summary>展开查看</summary>

<ol>
<li>springboot项目的入口类上有一个注解@SpringBootApplication，这个注解包含3个注解，分别为@SpringBootConfiguration、@EnableAutoConfiguation和@ComponentScan</li>
<li><strong>@EnableAutoConfiguation</strong>实现自动化配置的核心注解，该注解通过@Import注解导入对应的配置选择器。所有的自动配置类都会在“META-INF&#x2F;spring.factories”文件中，位于对应的自动配置jar包中。</li>
<li>@ConditionalOnClass注解会判断是否有对应的class文件，如果有则加载该类，将该类的bean放入spring容器中。</li>
</ol>
</details>

<h4 id="bean初始化之前运行一段方法的做法"><a href="#bean初始化之前运行一段方法的做法" class="headerlink" title="bean初始化之前运行一段方法的做法"></a>bean初始化之前运行一段方法的做法</h4><details>
<summary>展开查看</summary>

<ul>
<li>在 bean 类中实现 InitializingBean 接口,并覆写 afterPropertiesSet() 方法</li>
<li>在 bean 类的方法上添加 @PostConstruct 注解</li>
</ul>
</details>

<h4 id="spring事务失效的场景"><a href="#spring事务失效的场景" class="headerlink" title="spring事务失效的场景"></a>spring事务失效的场景</h4><details>
<summary>展开查看</summary>

<ul>
<li>自己实现了异常捕获处理</li>
<li>抛出检查异常（编译时异常）</li>
<li>事务注解在非public方法上</li>
</ul>
</details>

<h4 id="mybatis中-和-的区别"><a href="#mybatis中-和-的区别" class="headerlink" title="mybatis中$和#的区别"></a>mybatis中$和#的区别</h4><details>
<summary>展开查看</summary>

<ul>
<li>“#” 预编译的方式，会将参数值设置为预编译语句中的占位符。</li>
<li>“$” 直接替换的方法，会直接将参数值按照字符串的形式替换到SQL语句中，会有潜在的sql注入风险   适用于动态拼接</li>
</ul>
</details>

<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="MySQL-为什么使用-B-树来作索引，对比-B-树它的优点和缺点是什么？"><a href="#MySQL-为什么使用-B-树来作索引，对比-B-树它的优点和缺点是什么？" class="headerlink" title="MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么？"></a>MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么？</h4><details>
<summary>展开查看</summary>

<p>B+树相比于B树有几个显著的优点：B+树具备更少的IO次数（非叶子节点只存储索引），更稳定的查询效率（只搜索叶子节点），B+树的所有叶子节点构成一个有序链表，更适用于范围查找。  </p>
<p>缺点就是需要维护叶子节点之间的指针</p>
</details>

<h4 id="简述乐观锁以及悲观锁的区别以及使用场景"><a href="#简述乐观锁以及悲观锁的区别以及使用场景" class="headerlink" title="简述乐观锁以及悲观锁的区别以及使用场景"></a>简述乐观锁以及悲观锁的区别以及使用场景</h4><details>
<summary>展开查看</summary>

<p>乐观锁假设不会出现并发问题，不限制线程对数据进行更新，在提交修改时会验证是否被修改了。mysql事务并发控制中使用的是MVCC，适用于读比较多的场景。</p>
<p>悲观锁则每次在获取资源时都会上锁，直到处理完。mysql中直接就叫做锁，适用于写比较多的场景</p>
</details>

<h4 id="简述-MySQL-常见索引类型，介绍一下覆盖索引"><a href="#简述-MySQL-常见索引类型，介绍一下覆盖索引" class="headerlink" title="简述 MySQL 常见索引类型，介绍一下覆盖索引"></a>简述 MySQL 常见索引类型，介绍一下覆盖索引</h4><details>
<summary>展开查看</summary>

<p>（聚簇索引和非聚簇索引有什么区别？）</p>
<p>聚簇索引：索引结构和数据一起存放，如InnoDB的B+树</p>
<p>非聚簇索引：索引结构和数据分开存放，如MyISAM的B+树</p>
<p>覆盖索引：索引包含所有需要查询的字段，这样在查询时可以直接从索引中获取数据，不需要查表</p>
<p>联合索引：使用表中的多个字段创建索引         最左前缀匹配原则</p>
</details>

<h4 id="简述事务的四大特性"><a href="#简述事务的四大特性" class="headerlink" title="简述事务的四大特性"></a>简述事务的四大特性</h4><details>
<summary>展开查看</summary>

<p>ACID  原子性：指令要么全部成功，要么全部失败；隔离性：一个用户的事务不会被其他事务干扰；持久性：数据的改变是持久的，即使数据库发生故障也能恢复；一致性：执行事务前后，数据保持一致</p>
</details>

<h4 id="MySQL-有哪些常见的存储引擎？它们的区别是什么"><a href="#MySQL-有哪些常见的存储引擎？它们的区别是什么" class="headerlink" title="MySQL 有哪些常见的存储引擎？它们的区别是什么"></a>MySQL 有哪些常见的存储引擎？它们的区别是什么</h4><details>
<summary>展开查看</summary>

<p>（什么是数据库事务，MySQL 为什么会使用 InnoDB 作为默认选项）</p>
<p>（MySQL中 InnoDB 和 MylSAM 的区别是什么？）</p>
<p>InnoDB：支持行级锁，事务型的存储引擎，支持数据库崩溃后的安全恢复，索引类型是聚簇索引</p>
<p>MyISAM：只支持表级锁，不支持事务，不支持数据库崩溃后的安全恢复，索引类型是非聚簇索引</p>
</details>

<h4 id="数据库的事务隔离级别有哪些？各有哪些优缺点？"><a href="#数据库的事务隔离级别有哪些？各有哪些优缺点？" class="headerlink" title="数据库的事务隔离级别有哪些？各有哪些优缺点？"></a>数据库的事务隔离级别有哪些？各有哪些优缺点？</h4><details>
<summary>展开查看</summary>

<p>读取未提交：可能会脏读、不可重复读、幻读</p>
<p>读取已提交：可能会不可重复读和幻读</p>
<p>可重复读：指事务执行期间，<strong>其他事务所做的修改对当前事务都不可见</strong>，默认的事务隔离级别，幻读还有可能发生</p>
<p>可串行化：所有事务逐个执行</p>
</details>

<h4 id="简述脏读和幻读的发生场景，InnoDB-是如何解决幻读的？"><a href="#简述脏读和幻读的发生场景，InnoDB-是如何解决幻读的？" class="headerlink" title="简述脏读和幻读的发生场景，InnoDB 是如何解决幻读的？"></a>简述脏读和幻读的发生场景，InnoDB 是如何解决幻读的？</h4><details>
<summary>展开查看</summary>

<ul>
<li>脏读：一个事务对数据进行了修改，另一个事务读取了这个修改后的数据，然后前一个事务失败回滚了</li>
<li>幻读：一个事务在读取表中数据的过程中，又新插入了几行记录。</li>
</ul>
<p>通过MVCC或者临键锁（记录锁+间隙锁）防止新数据插入。</p>
</details>

<h4 id="简述什么是最左匹配原则"><a href="#简述什么是最左匹配原则" class="headerlink" title="简述什么是最左匹配原则"></a>简述什么是最左匹配原则</h4><details>
<summary>展开查看</summary>

<p>联合索引中的最左前缀匹配原则，会根据最左侧的字段过滤一批数据，直至联合索引中的字段全部匹配完成。</p>
</details>

<h4 id="简述-MySQL-MVCC-的实现原理"><a href="#简述-MySQL-MVCC-的实现原理" class="headerlink" title="简述 MySQL MVCC 的实现原理"></a>简述 MySQL MVCC 的实现原理</h4><details>
<summary>展开查看</summary>
MVCC会对一份数据存储多个版本，通过undo log（这个日志会记录某行数据多个版本的数据）实现

<p>读操作：当一个事务执行读操作，会先创建快照，使用快照读取，这样其他事务的修改不会影响到当前事务的读取。</p>
<p>写操作：事务执行写操作时，会生成一个新的数据版本，并将修改后的数据写入数据库。</p>
</details>

<h4 id="数据库如何设计索引，如何优化查询？"><a href="#数据库如何设计索引，如何优化查询？" class="headerlink" title="数据库如何设计索引，如何优化查询？"></a>数据库如何设计索引，如何优化查询？</h4><details>
<summary>展开查看</summary>

<ul>
<li>联合索引：对于多个列经常一起用作查询条件的情况，创建联合索引提高查询效率。</li>
<li>使用覆盖索引；对于联合索引，满足最左前缀匹配原则；避免使用函数或者%开头的like模糊查找使索引失效</li>
</ul>
</details>

<h4 id="MySQL的主从同步机制"><a href="#MySQL的主从同步机制" class="headerlink" title="MySQL的主从同步机制"></a>MySQL的主从同步机制</h4><details>
<summary>展开查看</summary>
基于**binlog**日志的机制，实现主服务器到从服务器数据的同步。（有点像读写分离那一块的）

<p><code>binlog</code>文件记录了MySQL数据库中数据的所有变化，主库将数据的变化写入到<code>binlog</code>，从库将<code>binlog</code>写入到<code>relay log</code>，再从relay log同步数据到本地。</p>
</details>

<h4 id="sql优化手段"><a href="#sql优化手段" class="headerlink" title="sql优化手段"></a>sql优化手段</h4><details>
<summary>展开查看</summary>

<ul>
<li>避免使用select * 语句     消耗CPU、无法得到覆盖索引的优化</li>
<li>避免使用外键或者级联操作      对分库分表不友好</li>
<li>选择合适的字段类型       存储字节越少，，占用空间越小，性能也越好</li>
</ul>
</details>

<h4 id="mysql的查询过程"><a href="#mysql的查询过程" class="headerlink" title="mysql的查询过程"></a>mysql的查询过程</h4><details>
<summary>展开查看</summary>

<p>连接器-查询缓存（已移除）-分析器-优化器-执行器</p>
<p>分析器分析sql语句的语法；优化器根据索引、表的大小、数据分布等选择合适的执行方式；执行器打开表，建立读写锁，调用存储引擎的接口执行查询；存储引擎根据查询条件定位到B+树叶子节点，从叶子节点中读取到对应的数据行。</p>
</details>

<h4 id="InnoDB存储引擎有哪两种行级锁"><a href="#InnoDB存储引擎有哪两种行级锁" class="headerlink" title="InnoDB存储引擎有哪两种行级锁"></a>InnoDB存储引擎有哪两种行级锁</h4><details>
<summary>展开查看</summary>

<p>共享锁（多个事务可以同时对同一行数据加共享锁）和排他锁</p>
</details>

<h4 id="mysql查询sql语句的查询时间"><a href="#mysql查询sql语句的查询时间" class="headerlink" title="mysql查询sql语句的查询时间"></a>mysql查询sql语句的查询时间</h4><details>
<summary>展开查看</summary>

<p><code>SHOW PROFILES</code> 命令可以用来查看最近执行的 SQL 语句的执行时间</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> profiling <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> your_table <span class="keyword">WHERE</span> your_conditions;</span><br><span class="line"><span class="keyword">SHOW</span> PROFILES;</span><br></pre></td></tr></table></figure>
</details>

<h4 id="distinct关键字"><a href="#distinct关键字" class="headerlink" title="distinct关键字"></a>distinct关键字</h4><details>
<summary>展开查看</summary>

<p>从查询结果中去除重复的行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>
</details>

<h4 id="左连接和右连接"><a href="#左连接和右连接" class="headerlink" title="左连接和右连接"></a>左连接和右连接</h4><details>
<summary>展开查看</summary>

<p>左连接是基于左边的表来连接右边的表，左连接返回左表中所有行，以及右表中与左表中匹配的行，如果右表中没有与左表匹配的行，则返回NULL值。</p>
<p>右连接相反。</p>
</details>

<h4 id="哪些sql语句会产生临时表"><a href="#哪些sql语句会产生临时表" class="headerlink" title="哪些sql语句会产生临时表"></a>哪些sql语句会产生临时表</h4><details>
<summary>展开查看</summary>

<ul>
<li>排序  order by和group by</li>
<li>连接 </li>
<li>子查询</li>
</ul>
</details>

<h4 id="mysql如何实现分布式锁，底层原理是什么"><a href="#mysql如何实现分布式锁，底层原理是什么" class="headerlink" title="mysql如何实现分布式锁，底层原理是什么"></a>mysql如何实现分布式锁，底层原理是什么</h4><details>
<summary>展开查看</summary>

<p>在mysql数据库中创建一个用于存储锁信息的表，包含三个字段：锁的名称（唯一索引）、锁的持有者（线程ID等标识）、锁的过期时间（可选）</p>
<p>获取锁则通过“INSERT”向锁表插入一条记录，释放锁则通过“DELETE”从锁表中删除相应的记录。</p>
<p>原理：</p>
<ul>
<li>事务：同一个事务，要么获取锁成功，要么获取锁失败；</li>
<li>行级锁：INSERT和DELETE都涉及到行级锁的获取，在执行时，都会为行加上行级锁。</li>
</ul>
</details>





<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="Redis-如何实现分布式锁？"><a href="#Redis-如何实现分布式锁？" class="headerlink" title="Redis 如何实现分布式锁？"></a>Redis 如何实现分布式锁？</h4><details>
<summary>展开查看</summary>

<ul>
<li>基于SETNX实现，它的原理是如果key存在则返回0，key不存在就创建key，这样只有第一个执行SETNX的客户端才能成功，这样第一个客户端就获取到了锁，直到锁过期释放</li>
<li>基于SET实现，SET添加了NX和EX的参数，分别起到SETNX和EXPIRE的效果</li>
<li>Redlock算法：获取当前时间，依次向5个Redis获取锁，若在3个以上成功，且获取锁的时间小于锁的有效时间，则获得锁。</li>
</ul>
<p><strong>具体实现：</strong> redission中的watch dog机制，获取锁之后会将锁的线程放入到redission维护的一个map中，每10s查询一次，若还持有锁，则会延长时间。</p>
</details>

<h4 id="简述-Redis-持久化中-RDB-以及-AOF-方案的优缺点"><a href="#简述-Redis-持久化中-RDB-以及-AOF-方案的优缺点" class="headerlink" title="简述 Redis 持久化中 RDB 以及 AOF 方案的优缺点"></a>简述 Redis 持久化中 RDB 以及 AOF 方案的优缺点</h4><details>

<summary>展开查看</summary>
RDB

<ul>
<li>高性能，通过<strong>fork子进程</strong>（savebg）完成持久化；RDB文件在指定的时间间隔内生成，而且是经过压缩的二进制数据，便于备份与恢复。</li>
<li>Redis发生故障会丢失最近的一次快照；持久化是周期性的，不能保证每个操作都持久化到磁盘，不适用于实时持久化</li>
</ul>
<p>AOF</p>
<ul>
<li>AOF持久化记录了每个操作命令，可以确保Redis数据的完整性，即使发生故障也能恢复；几乎是实时记录每个写操作，适用于<strong>实时持久化</strong></li>
<li>AOF文件比RDB大很多，重写也会消耗资源；恢复数据需要依次执行每个写命令，速度非常慢。</li>
</ul>
</details>

<h4 id="简述-Redis-中常见类型的底层数据结构"><a href="#简述-Redis-中常见类型的底层数据结构" class="headerlink" title="简述 Redis 中常见类型的底层数据结构"></a>简述 Redis 中常见类型的底层数据结构</h4><details>
<summary>展开查看</summary>

<p>String（SDS）、Hash、List、Set、Zset（跳表）</p>
</details>

<h4 id="为什么-Redis-在单线程下能如此快？"><a href="#为什么-Redis-在单线程下能如此快？" class="headerlink" title="为什么 Redis 在单线程下能如此快？"></a>为什么 Redis 在单线程下能如此快？</h4><details>
<summary>展开查看</summary>

<p>读写命令是单线程，但通过<strong>非阻塞IO多路复用程序</strong>来监听多个套接字，通过单线程处理多个客户端的请求，减少了线程切换和同步开销。</p>
</details>

<h4 id="简述-Redis-的线程模型以及底层架构设计"><a href="#简述-Redis-的线程模型以及底层架构设计" class="headerlink" title="简述 Redis 的线程模型以及底层架构设计"></a>简述 Redis 的线程模型以及底层架构设计</h4><details>
<summary>展开查看</summary>

<p>基于<strong>Reactor</strong>模式（核心就是非阻塞IO）设计了<strong>文件事件处理器</strong>，非阻塞IO多路复用程序和多个客户端都是这个处理器的一部分。</p>
<p>读写命令都是单线程，多线程体现在网络数据的读写。</p>
</details>

<h4 id="简述-Redis-的过期机制和内存淘汰策略"><a href="#简述-Redis-的过期机制和内存淘汰策略" class="headerlink" title="简述 Redis 的过期机制和内存淘汰策略"></a>简述 Redis 的过期机制和内存淘汰策略</h4><details>
<summary>展开查看</summary>

<p>过期机制：定期清理和惰性清理</p>
<p>内存淘汰策略：lru、ttl、random</p>
</details>

<h4 id="简述-Redis-的哨兵机制"><a href="#简述-Redis-的哨兵机制" class="headerlink" title="简述 Redis 的哨兵机制"></a>简述 Redis 的哨兵机制</h4><details>
<summary>展开查看</summary>

<p>它主要用于监控 Redis 主从服务器的运行状态，自动完成故障转移（failover），并通过订阅和通知机制告知客户端关于 Redis 系统状态的变化。</p>
<p><strong>选举过程</strong>：当哨兵发现主节点失效时，它会在哨兵系统中发起选举，选出一个哨兵作为领导者来执行自动故障转移的操作。</p>
</details>

<h4 id="简述-Redis-如何处理热点-key-访问"><a href="#简述-Redis-如何处理热点-key-访问" class="headerlink" title="简述 Redis 如何处理热点 key 访问"></a>简述 Redis 如何处理热点 key 访问</h4><details>
<summary>展开查看</summary>

<p>读写分离，分为读节点和写节点</p>
<p>Redis cluster：热点数据分散存储在多个Redis节点上</p>
</details>

<h4 id="简述-Redis-中如何防止缓存雪崩和缓存击穿和缓存穿透"><a href="#简述-Redis-中如何防止缓存雪崩和缓存击穿和缓存穿透" class="headerlink" title="简述 Redis 中如何防止缓存雪崩和缓存击穿和缓存穿透"></a>简述 Redis 中如何防止缓存雪崩和缓存击穿和缓存穿透</h4><details>
<summary>展开查看</summary>

<p>缓存穿透：缓存无效key，设置布隆过滤器（把所有可能出现的值存入布隆过滤器，01存储）</p>
<p>缓存雪崩：Redis中多个key同时过期或者Redis崩溃，导致数据库请求量暴增  针对Redis崩溃，可以采用Redis集群或者限流；针对热点key过期，参考缓存击穿；针对大量key同时过期，给key设置随机过期时间或者lazy-free策略（采用异步方式释放过期的key）</p>
<p>缓存击穿：Redis热点key过期，导致数据库请求量暴增    缓存提前预热，设置永不过期（不推荐）</p>
</details>

<h4 id="简述-Redis-中跳表的应用以及优缺点"><a href="#简述-Redis-中跳表的应用以及优缺点" class="headerlink" title="简述 Redis 中跳表的应用以及优缺点"></a>简述 Redis 中跳表的应用以及优缺点</h4><details>
<summary>展开查看</summary>
跳表是ZSet的底层实现，相比于平衡树和红黑树，它有更好的区间查找效率，不需要像平衡树和红黑树要通过旋转维持平衡，缺点是跳表会在多个层次上存储节点的索引，空间开销大。

<p>跳表每个节点都包含一个数据域和若干个指针域，每个节点都指向同一水平上的下一个节点和其上一层节点；跳表是由多层链表组成的，每一层都是一个普通的链表；高度越高的节点出现的概率越小。查找、插入、删除的平均复杂度为O(logn)。</p>
</details>

<h4 id="简述-Redis-集群配置以及基础原理"><a href="#简述-Redis-集群配置以及基础原理" class="headerlink" title="简述 Redis 集群配置以及基础原理"></a>简述 Redis 集群配置以及基础原理</h4><details>
<summary>展开查看</summary>

<p>Redis集群包含多个节点，这些节点通过网络连接形成集群。每个节点都配置有自己的IP地址和端口号，以便集群中的其他节点可以与之通信。节点之间的通信使用TCP连接，并且这些连接是永久保持的。</p>
</details>

<h4 id="redis高可用的做法"><a href="#redis高可用的做法" class="headerlink" title="redis高可用的做法"></a>redis高可用的做法</h4><details>
<summary>展开查看</summary>

<p>高可用是指系统在面对各种故障情况下，保持长时间的可用性和稳定性。</p>
<ul>
<li>主从复制：redis集群中分为主节点和从节点，主从复制是指将一个 Redis 服务器（主节点）的数据复制到其他 Redis 服务器（从节点）上。主从复制提供了数据冗余备份、读写分离以及故障恢复等功能。</li>
<li>哨兵机制：主要用于监控 Redis 主从服务器的运行状态，自动完成故障转移。当哨兵发现主节点失效时，它会在哨兵系统中发起选举，选出一个哨兵作为领导者来执行自动故障转移的操作。</li>
<li>持久化：ROB和AOF方式实现持久化</li>
</ul>
</details>

<h4 id="redis分布式锁"><a href="#redis分布式锁" class="headerlink" title="redis分布式锁"></a>redis分布式锁</h4><p>问：采用setnx实现分布式锁，如果有两个线程同时获取锁，极端情况下两个线程都能获取到锁吗？</p>
<details>
<summary>展开查看</summary>

<p>答：是有可能都获取到锁的，这种情况被称为“锁竞争”。</p>
</details>

<h3 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h3><h4 id="消息模型和组件"><a href="#消息模型和组件" class="headerlink" title="消息模型和组件"></a>消息模型和组件</h4><details>
<summary>展开查看</summary>

<p>早期使用的是队列模型，使用队列作为消息通信载体，但是使用队列有一些问题，一条消息只能被一个消费者使用，如果我想多个消费者消费同一条消息（广播），则实现不了。</p>
<p>现在使用的是<strong>发布-订阅模型</strong>，使用主题topic作为消息通信载体，一个生产者发布了一个主题，则所有订阅了这个主题的消费者都能接收到消息（广播），当只有一个消费者的时候，就退化成了队列模型。</p>
<p><strong>组件：</strong>生产者、消费者、话题、broker代理、partition分区</p>
<p>一个broker中可以有多个topic，一个topic中可以有多个partition</p>
</details>

<h4 id="kafka怎么保证消息消费的顺序"><a href="#kafka怎么保证消息消费的顺序" class="headerlink" title="kafka怎么保证消息消费的顺序"></a>kafka怎么保证消息消费的顺序</h4><details>
<summary>展开查看</summary>

<p>一个topic中可能有多个partition，消息被追加到partition中会计算偏移量，然后放入partition，如果有多个partition，并不能保证先存入的消息先被消费。</p>
<p>有两种方法：1、一个topic中只有一个partition，2、生产者将消息放入消息队列时指定key或者partition。</p>
</details>

<h4 id="kafka怎么保证消息不丢失"><a href="#kafka怎么保证消息不丢失" class="headerlink" title="kafka怎么保证消息不丢失"></a>kafka怎么保证消息不丢失</h4><details>
<summary>展开查看</summary>

<ul>
<li>生产者</li>
</ul>
<p>因为网络原因，生产者发送失败会重试，0间隔重试10次，若重试失败消息会进入死信队列（特殊的消息队列），死信队列有两种处理方式：为死信队列设置一个专门的消息处理器，处理方法比如记录日志、发送警报或通知；重新消费这些消息。</p>
<ul>
<li>消费者</li>
</ul>
<p>当消费者拉取到partition的某个消息之后，消费者会自动提交offset，如果消费者刚拿到消息时突然挂掉了，则这条消息就丢失了。自动提交offset——&gt;手动提交，但是可能出现重复消费的问题。</p>
<ul>
<li>kafka服务器</li>
</ul>
<p>kafka为partition引入了多副本机制，多个副本之间会有个leader，除了leader其他称作follower，发送的消息会被发送到leader上，然后follower会从leader中拉取消息同步，如果leader挂掉的时候，还有follower没有同步，则丢失了消息（leader挂了之后，会选择一个follower作为leader，如果这个follower没有同步好消息，则丢失了消息）。</p>
<p>可以设置acks &#x3D; all，这样所有follower都同步消息之后才会响应服务器。</p>
</details>

<h4 id="kafka如何保证消息不重复消费"><a href="#kafka如何保证消息不重复消费" class="headerlink" title="kafka如何保证消息不重复消费"></a>kafka如何保证消息不重复消费</h4><details>
<summary>展开查看</summary>

<p>根本原因：消费者端已经消费的消息没有成功提交offset</p>
<p>解决方法：消费消息服务做幂等校验，比如Redis的set，MySQL的主键等天然的幂等功能。</p>
</details>

<h4 id="kafka高性能的原因"><a href="#kafka高性能的原因" class="headerlink" title="kafka高性能的原因"></a>kafka高性能的原因</h4><details>
<summary>展开查看</summary>

<ul>
<li>磁盘顺序读写</li>
<li>页缓存：磁盘中的数据缓存到内存，对磁盘的访问变成对内存的访问</li>
</ul>
</details>

<h4 id="kafka的ISR机制"><a href="#kafka的ISR机制" class="headerlink" title="kafka的ISR机制"></a>kafka的ISR机制</h4><p>In-Sync Replica Set是kafka为每个分区维护的一个副本集合，这些副本中有一个leader和若干个follower。</p>
<p>策略：</p>
<ul>
<li>acks &#x3D; all 默认值为1，表示消息被leader副本接受到之后就算被成功发送，acks &#x3D; all表示所有ISR列表的副本全部收到消息时，生产者才会接收到来组服务器的响应。</li>
<li>replication.factor &gt;&#x3D; 3 保证每个分区至少有3个副本</li>
<li>min.insync.replicas &gt; 1 消息至少要被写入到2个副本才算被成功发送</li>
</ul>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="网络分层模型"><a href="#网络分层模型" class="headerlink" title="网络分层模型"></a>网络分层模型</h4><h5 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h5><details>
<summary>展开查看</summary>

<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/osi-7-model.png" alt="OSI 七层模型"></p>
</details>

<h5 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP&#x2F;IP四层模型"></a>TCP&#x2F;IP四层模型</h5><details>
<summary>展开查看</summary>

<ol>
<li>应用层（应用层、表示层、会话层）</li>
<li>传输层</li>
<li>网络层</li>
<li>网络接口层（数据链路层、物理层）</li>
</ol>
</details>

<h4 id="打开一个网站，会用到哪些协议"><a href="#打开一个网站，会用到哪些协议" class="headerlink" title="打开一个网站，会用到哪些协议"></a>打开一个网站，会用到哪些协议</h4><details>
<summary>展开查看</summary>

<ol>
<li>在浏览器中输入网页的URL</li>
<li>浏览器通过DNS协议，获取域名对应的IP地址；</li>
<li>浏览器根据IP和端口号，向目标服务器发起一个TCP请求</li>
<li>浏览器在TCP连接上，向服务器发送一个HTTP请求，请求获取网页的内容</li>
<li>服务器收到HTTP请求后，会发一个HTTP响应报文给浏览器</li>
<li>浏览器收到HTTP响应后，解析响应体中的HTML样式，同时根据HTML中其他资源（图片、CSS、js）的URL再次发起HTTP请求，直至网页资源全部加载</li>
</ol>
</details>

<h4 id="HTTP和HTTPS有什么区别"><a href="#HTTP和HTTPS有什么区别" class="headerlink" title="HTTP和HTTPS有什么区别"></a>HTTP和HTTPS有什么区别</h4><details>
<summary>展开查看</summary>

<ul>
<li>端口号：HTTP默认是80，HTTPs默认是443</li>
<li>URL前缀</li>
<li>安全性：HTTPS运行在SSL&#x2F;TLS协议上，SSL&#x2F;TLS运行在TCP上，所有传输的内容都经过加密。</li>
<li>HTTPS连接建立相对复杂，在tcp三次握手后，还要进行SSL&#x2F;TLS的握手过程。</li>
<li>HTTPS需要向CA申请数字证书，保证服务器的身份是可信的。</li>
</ul>
</details>

<h4 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h4><details>
<summary>展开查看</summary>

<ul>
<li>GET通常用于获取或查询资源，POST用于创建或修改资源；</li>
<li>GET是幂等的，POST是不幂等的</li>
<li>GET请求的参数放在URL中，POST请求的参数放在请求体中</li>
<li>GET可以被缓存，POST不行</li>
</ul>
</details>

<h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><details>
<summary>展开查看</summary>

<table>
<thead>
<tr>
<th></th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td>是否面向连接</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否可靠</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否有状态</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>传输效率</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>传输形式</td>
<td>字节流</td>
<td>数据报文段</td>
</tr>
<tr>
<td>首部开销</td>
<td>20-60 bytes</td>
<td>8bytes</td>
</tr>
<tr>
<td>是否支持多播或广播</td>
<td>点对点</td>
<td>一对一，一对多，多对多</td>
</tr>
<tr>
<td>应用</td>
<td>文件传输、远程登录</td>
<td>即时通信、直播</td>
</tr>
</tbody></table>
</details>

<h4 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a>TCP的三次握手和四次挥手</h4><h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><details>
<summary>展开查看</summary>

<ol>
<li>客户端向服务端发送一个SYN(SEQ &#x3D; x)的请求报文；</li>
<li>服务端在接收之后向客户端发送一个SYN(SEQ&#x3D;y)和一个ACK(ACK &#x3D; x+1)报文；</li>
<li>客户端在接收之后向服务端发送一个ACK(ACK&#x3D;y+1)报文。</li>
</ol>
<p>第一次握手之后，服务端确定了客户端发送正常，自己接收正常；</p>
<p>第二次握手之后，客户端确定了自己发送和接收正常，服务端接收和发送正常，服务端确定了自己接收正常，客户端发送正常；</p>
<p>第三次握手之后，客户端确定了自己发送和接收正常，服务端接收和发送正常，服务端确定了自己发送和接收正常，客户端发送和接收正常；</p>
<p>建立连接。</p>
</details>

<h5 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h5><details>
<summary>展开查看</summary>

<ol>
<li>客户端向服务端发送一个FIN(SEQ&#x3D;x)的请求报文；</li>
<li>服务端在接收之后向客户端发送一个ACK(ACK&#x3D;x+1)报文；</li>
<li>服务端向客户端发送一个FIN(SEQ&#x3D;y)的请求报文；</li>
<li>客户端在接收之后向服务端发送一个ACK(ACK&#x3D;y+1)报文，客户端等待若干时间，若服务端无响应，则关闭连接。</li>
</ol>
<p>前两次挥手是客户端表明要断开连接，后两次挥手是服务端确定要断开连接。</p>
</details>

<h4 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h4><details>
<summary>展开查看</summary>

<p>避免发送方的数据填满整个网络，为了调节发送数据的量，定义了一个拥塞窗口的概念。</p>
<p>网络中没有出现拥塞，cwnd就会增大；网络中出现了拥塞，cwnd就减少。</p>
<p>算法：</p>
<ul>
<li>慢启动：发送方每收到一个ACK，拥塞窗口cwnd大小加1    cwnd &lt; ssthresh（慢启动门限）</li>
<li>拥塞避免：发送方每收到一个ACK，cwnd增加1&#x2F;cwnd        cwnd &gt;&#x3D; ssthresh</li>
<li>拥塞发生  ssthresh设为 cwnd &#x2F; 2   cwnd初始化值</li>
<li>快速恢复</li>
</ul>
</details>

<h4 id="TCP延迟确认"><a href="#TCP延迟确认" class="headerlink" title="TCP延迟确认"></a>TCP延迟确认</h4><details>
<summary>展开查看</summary>

<p>当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</p>
</details>

<h4 id="TCP超时重传"><a href="#TCP超时重传" class="headerlink" title="TCP超时重传"></a>TCP超时重传</h4><details>
<summary>展开查看</summary>

<p>超时重传，两种情况：数据包丢失；应答丢失。超时时间应略大于往返时延</p>
</details>

<h4 id="TCP滑动窗口和流量控制"><a href="#TCP滑动窗口和流量控制" class="headerlink" title="TCP滑动窗口和流量控制"></a>TCP滑动窗口和流量控制</h4><details>
<summary>展开查看</summary>

<p>一问一答的通信效率不高，为解决这个问题，tcp引入了窗口的概念，发送方可以连续发送 窗口大小 的请求 (批量思想)<br>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量。通过滑动窗口实现的</p>
</details>

<h4 id="TCP粘包和拆包"><a href="#TCP粘包和拆包" class="headerlink" title="TCP粘包和拆包"></a>TCP粘包和拆包</h4><details>
<summary>展开查看</summary>

<p>TCP传输的是字节流，它会根据缓冲区的实际情况进行包的划分（发送和接收），由此会导致上层业务的一个完整的包被拆分成多个包进行发送（“拆包”），或者多个小包被封装成一个大的数据包进行发送（“粘包”），这就是所谓的TCP的拆包和粘包问题。</p>
</details>

<h4 id="http常见状态码"><a href="#http常见状态码" class="headerlink" title="http常见状态码"></a>http常见状态码</h4><details>
<summary>展开查看</summary>

<ul>
<li>1xx  正在处理</li>
<li>2xx  处理完成</li>
<li>3xx  处理需要额外的操作——重定向</li>
<li>4xx  客户端错误</li>
<li>5xx  服务端错误</li>
</ul>
</details>

<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h4 id="线程间的同步方式"><a href="#线程间的同步方式" class="headerlink" title="线程间的同步方式"></a>线程间的同步方式</h4><details>
<summary>展开查看</summary>

<ul>
<li>互斥锁</li>
<li>读写锁</li>
<li>信号量</li>
<li>屏障       同步原语，等待多个线程到达某个点再一起继续执行</li>
<li>事件       通知的方式保持线程同步</li>
</ul>
</details>

<h4 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h4><details>
<summary>展开查看</summary>

<ul>
<li>管道</li>
<li>信号</li>
<li>消息队列</li>
<li>信号量</li>
<li>共享内存</li>
<li>套接字</li>
</ul>
</details>

<h4 id="进程的调度算法"><a href="#进程的调度算法" class="headerlink" title="进程的调度算法"></a>进程的调度算法</h4><details>
<summary>展开查看</summary>

<ul>
<li><strong>先到先服务调度算法(FCFS，First Come, First Served)</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>短作业优先的调度算法(SJF，Shortest Job First)</strong> : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>时间片轮转调度算法（RR，Round-Robin）</strong> : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li>
<li><strong>多级反馈队列调度算法（MFQ，Multi-level Feedback Queue）</strong>：前面介绍的几种进程调度的算法都有一定的局限性。如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong> 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</li>
<li><strong>优先级调度算法（Priority）</strong>：为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li>
</ul>
</details>

<h4 id="僵尸进程与孤儿进程"><a href="#僵尸进程与孤儿进程" class="headerlink" title="僵尸进程与孤儿进程"></a>僵尸进程与孤儿进程</h4><details>
<summary>展开查看</summary>

<p>子进程通常是通过 fork()系统调用创建的，该调用会创建一个新的进程，该进程是原有进程的一个副本。子进程和父进程的运行是相互独立的，它们各自拥有自己的 PCB，即使父进程结束了，子进程仍然可以继续运行。</p>
<ul>
<li><strong>僵尸进程：</strong>子进程已经终止，但是其父进程仍在运行，父进程没有调用wait()系统调用来释放子进程占用的资源。</li>
<li><strong>孤儿进程：</strong>父进程已经终止，但是子进程仍在运行。</li>
</ul>
</details>

<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><details>
<summary>展开查看</summary>

<p>多个线程&#x2F;进程同时被阻塞，都在等待某个资源被释放</p>
</details>

<h5 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a>死锁的四个必要条件</h5><details>
<summary>展开查看</summary>

<ul>
<li>互斥</li>
<li>占用并等待</li>
<li>非抢占</li>
<li>循环等待</li>
</ul>
</details>

<h5 id="模拟死锁的代码"><a href="#模拟死锁的代码" class="headerlink" title="模拟死锁的代码"></a>模拟死锁的代码</h5><details>
<summary>展开查看</summary>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 1&quot;</span>).start();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</details>

<h5 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h5><h6 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h6><details>
<summary>展开查看</summary>

<ul>
<li>静态分配策略    一个进程在执行前申请到它所需要的所有资源      破坏了占用并等待条件</li>
<li>层次分配策略    一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程<br>要释放某层的一个资源时，必须先释放所占用的较高层的资源，破坏了循环等待条件</li>
</ul>
</details>

<h6 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h6><details>
<summary>展开查看</summary>

<p>当一个进程申请使用资源的时候，<strong>银行家算法</strong> 通过先 <strong>试探</strong> 分配给该进程资源，然后通过 <strong>安全性算法</strong> 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 <strong>真的分配资源给该进程</strong>。</p>
</details>



<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="动态规划和贪心有什么区别"><a href="#动态规划和贪心有什么区别" class="headerlink" title="动态规划和贪心有什么区别"></a>动态规划和贪心有什么区别</h4><details>
<summary>展开查看</summary>

<ul>
<li>动态规划采用自下而上的方式,通过求解子问题来逐步求解整个问题;贪心是采用自上而下的方式,做出局部最优选,希望能够得到全局最优解;</li>
<li>动态规划保证能够得到全局最优解,贪心在某些问题上只能近似最优解;</li>
<li>动态规划适用于有重叠子问题和最优子结构性质的问题。</li>
</ul>
</details>

<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="思路和代码"><a href="#思路和代码" class="headerlink" title="思路和代码"></a>思路和代码</h5><p>快速排序采用分治法的思想，将大规模的排序分解为若干个小规模的排序——每次选取一个基准元素（一般是选择当前规模的第一个元素），设置左指针指向当前区间的第一个元素位置，设置右指针指向当前区间的最后一个元素位置。每次对非空位置的指针进行操作，原始左指针指向的元素作为基准元素了，因此左指针为空，先判断右指针：当右指针指向的值小于基准值时，就将该值移动到左指针指向的空位置，再判断左指针。这样移动左右指针直至两个指针指向相同的位置，一轮快速排序结束，这时位于基准元素左边的元素均小于基准元素，位于基准元素右边的元素均大于基准元素。后面再对前面和后面两个区间进行快速排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个函数是进行一轮快速排序，并返回当前基准元素所在的位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[low];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[high] &gt;= temp &amp;&amp; low &lt; high)&#123;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = nums[high];</span><br><span class="line">        <span class="keyword">while</span>(nums[low] &lt;= temp &amp;&amp; low &lt; high)&#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[high] = nums[low];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    nums[low] = temp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">qsort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &gt;= high)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fenjie</span> <span class="operator">=</span> quicksort(nums, low, high);</span><br><span class="line">    quick(nums, low, fenjie - <span class="number">1</span>);</span><br><span class="line">    quick(nums, fenjie + <span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="复杂度和优化"><a href="#复杂度和优化" class="headerlink" title="复杂度和优化"></a>复杂度和优化</h5><p>空间复杂度平均O(logn),最坏递归n-1次,空间复杂度O(n) </p>
<p>时间复杂度平均O(nlogn),最坏原来为逆序,时间复杂度O(n ^ 2)</p>
<p>快速排序不是稳定的算法,在分割时会改变元素的相对位置</p>
<p>优化方法:1. 三数取中选择基准元素 2. 尾递归优化:每次递归完,如果左子数组元素个数小于右子数组元素的个数,则优先递归调用右子数组的排序,减少递归深度</p>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><h5 id="思路和代码-1"><a href="#思路和代码-1" class="headerlink" title="思路和代码"></a>思路和代码</h5><p>插入排序的思想是从第一个元素开始认定序列是有序的,在遍历的过程中比较当前的元素和前面有序的序列,找到当前元素应该在的位置,写入就好了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="comment">//保存当前元素值,在找到位置后插入</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="comment">//循环过程中不能改变i,因此用一个变量来作为循环时的判断</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span>(index - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; temp &lt; nums[index - <span class="number">1</span>])&#123;</span><br><span class="line">            nums[index] = nums[index - <span class="number">1</span>];</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到当前元素在有序序列中的位置,插入</span></span><br><span class="line">        nums[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度为O(n ^ 2),最好情况是有序的时候,时间复杂度O(n)</p>
<p>选择排序是稳定排序算法.</p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><h5 id="思路和代码-2"><a href="#思路和代码-2" class="headerlink" title="思路和代码"></a>思路和代码</h5><p>归并排序的核心就是分治法,先对完整的序列分为多个子序列,然后子序列内部进行排序,然后再两两合并子序列直到合成一个完整的序列.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并两个子序列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> mid)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)&#123;</span><br><span class="line">        temp[k++] = (nums[i] &gt; nums[j] ? nums[j++] : nums[i++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)&#123;</span><br><span class="line">        temp[k++] = nums[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= right)&#123;</span><br><span class="line">        temp[k++] = nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这是核心代码,在原数组上进行修改,将合并的序列从left下标开始赋值</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">        nums[left + i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//在merge函数中，前半部分到mid是闭的，因此这里要赋mid，而不是mid - 1</span></span><br><span class="line">    mergeSort(nums, left, mid);</span><br><span class="line">    mergeSort(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">    merge(nums, left, right, mid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h5><p>递归的深度为logn,每次排序的复杂度是O(n),因此时间复杂度O(nlogn).</p>
<p>空间复杂度在合并时需要创建数组,空间复杂度O(n).</p>
<p>归并排序是稳定的排序算法.</p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><h5 id="思路和代码-3"><a href="#思路和代码-3" class="headerlink" title="思路和代码"></a>思路和代码</h5><p>大顶堆是根节点的值大于其左右子节点的值, 堆排序的思路就是对数组建立大顶堆, 每次弹出根节点, 然后再调整大顶堆, 直至所有元素都弹出去, 是从最大值到最小值的顺序来排序。小顶堆就相反, 每次弹出最小元素。</p>
<p>建树的过程: 从二叉树的最后一个非叶子节点自下向上建树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">headify</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; n &amp;&amp; nums[left] &gt; nums[largest])&#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right &lt; n &amp;&amp; nums[right] &gt; nums[largest])&#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(largest != i)&#123;</span><br><span class="line">        <span class="comment">//交换左或右子节点和根节点的值</span></span><br><span class="line">        swap(nums, i, largest);</span><br><span class="line">        <span class="comment">//largest下标的较大值交换到根节点了，此时相当于是向下递归子树</span></span><br><span class="line">        headify(nums, largest, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">headSort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">//n/2-1下标的元素是二叉树最后一个非叶子节点，自下向上构建最大堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        headify(nums, i, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="comment">//堆排序的方法，将下标为0的元素（根节点）和当前最后一个下标的元素交换，然后重新建树，这样每次弹出的都是局部最大值，一直到元素全部弹出</span></span><br><span class="line">        swap(nums, <span class="number">0</span>, i);</span><br><span class="line">        headify(nums, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h5><p>建初始堆的时间复杂度O(n), 调整堆的时间复杂度O(logn), 调整n次, 因此时间复杂度O(nlogn)        堆的高度是O(logn)</p>
<p>空间复杂度O(1)</p>
<p>不稳定的排序算法</p>
<h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><h4 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;content&quot;</span> /path/to/log</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&quot;/content/&quot;</span> /path/to/log</span><br></pre></td></tr></table></figure>

<h5 id="grep的参数"><a href="#grep的参数" class="headerlink" title="grep的参数"></a>grep的参数</h5><p>-i   忽略大小写</p>
<p>-v  排除某内容的行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查找包含error但是不包含timeout的内容行</span></span><br><span class="line">grep <span class="string">&#x27;error&#x27;</span> /var/log/syslog | grep -v <span class="string">&#x27;timeout&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="查找创建时间两天内的文件"><a href="#查找创建时间两天内的文件" class="headerlink" title="查找创建时间两天内的文件"></a>查找创建时间两天内的文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -mtime -2</span><br></pre></td></tr></table></figure>

<h4 id="查看磁盘的使用率和占用空间"><a href="#查看磁盘的使用率和占用空间" class="headerlink" title="查看磁盘的使用率和占用空间"></a>查看磁盘的使用率和占用空间</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看磁盘的使用情况，磁盘大小和使用率</span></span><br><span class="line"><span class="built_in">df</span> -h</span><br><span class="line"><span class="comment">#查看目录或文件的使用情况，-s表示努力下占用空间的汇总</span></span><br><span class="line"><span class="built_in">du</span> -h</span><br></pre></td></tr></table></figure>

<h4 id="查看进程的端口"><a href="#查看进程的端口" class="headerlink" title="查看进程的端口"></a>查看进程的端口</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -p</span><br></pre></td></tr></table></figure>



<h2 id="横向项目"><a href="#横向项目" class="headerlink" title="横向项目"></a>横向项目</h2><h3 id="yolo模型部署在华为开发板上"><a href="#yolo模型部署在华为开发板上" class="headerlink" title="yolo模型部署在华为开发板上"></a>yolo模型部署在华为开发板上</h3><ol>
<li>首先是根据yolov5源码，通过网络上抓取到的人或者军事建筑目标的图片（手动打标签），训练出yolov5模型，这时候是pt模型文件；</li>
<li>通过yolov5源码中的export.py将pt模型导出ONNX模型；</li>
<li>通过ATC工具将ONNX模型转为OM模型</li>
</ol>
<h3 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h3><h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>MTR课表小程序是和组里同学和师兄一起开发的java项目，初衷是帮南理工的同学们查询课表、成绩等教务信息。主要的技术栈是springboot、mybatis-plus、redis、mysql、elasticsearch和kafka。</p>
<p>原来查询课表或者成绩都需要登录学校的教务网站，在手机上操作不太方便而且比较耗时，为了快捷且便利的查看课表，查询成绩、空教室以及校内交流，开发了这个微信小程序。</p>
<h3 id="我的工作"><a href="#我的工作" class="headerlink" title="我的工作"></a>我的工作</h3><p>我主要实现了登录模块和校内论坛模块</p>
<h4 id="登录模块"><a href="#登录模块" class="headerlink" title="登录模块"></a>登录模块</h4><p>第一个版本使用的是最常规的Session的登录方式（session-localStorage方案），后来改了多服务器以后，Session这种方式就出现了问题，首先就是Session不共享的问题。</p>
<p>我们最后选择了JWT（json web token），解决了Session共享的问题，用户登陆时，服务器端生成一个token令牌响应给前端。后续的请求中需要携带令牌到服务器端，服务器端可以解析token，得到用户信息做校验。jwt令牌会存在localstorage（本地浏览器）中，不需要总是重新登录</p>
<p><a target="_blank" rel="noopener" href="https://fangjun120.github.io/2023/11/12/11-00-37/">jwt</a>是目前最流行的跨域认证的解决方案，是基于token的认证授权机制。本质是一组字符串，由3个部分组成。jwt会将用户id和一些其他信息包装起来一起编码。</p>
<h5 id="如何获得教务信息"><a href="#如何获得教务信息" class="headerlink" title="如何获得教务信息"></a>如何获得教务信息</h5><p>学校教务有一个统一的入口，通过登录教务系统拿到一个cookie，再通过cookie访问课表、成绩等信息。</p>
<p>查课表：课表一学期都不会变，所以直接将课表缓存到前台，用户查询的时候直接从前台拿，微信小程序的localstorage有10MB的大小</p>
<h5 id="获取用户信息"><a href="#获取用户信息" class="headerlink" title="获取用户信息"></a>获取用户信息</h5><p>ThreadLocal 并不是一个Thread，而是Thread的局部变量。<br>ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。</p>
<p>可以用threalocal的set方法去存用户的信息，然后用get方法获取当前线程下的信息，不需要加锁。</p>
<h5 id="nginx反向代理、限流"><a href="#nginx反向代理、限流" class="headerlink" title="nginx反向代理、限流"></a>nginx反向代理、限流</h5><p>用了三台2核4g的服务器，做nginx反向代理，采用轮询的方式做负载均衡。</p>
<p>令牌桶算法：令牌以固定速率产生，缓存到令牌桶里面。令牌桶放满时，多余的令牌被丢弃。每次请求要消耗等比例的令牌才能被处理。令牌不够的时候，请求被缓存。</p>
<h4 id="论坛模块"><a href="#论坛模块" class="headerlink" title="论坛模块"></a>论坛模块</h4><h5 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h5><p>帖子表：帖子id、发布者id、标题、内容、发布时间、评论数量</p>
<p>评论表：评论id、帖子id、评论用户id、评论时间、内容、回复用户id</p>
<p>评论图片表：帖子id、图片链接</p>
<h5 id="评论实现方式"><a href="#评论实现方式" class="headerlink" title="评论实现方式"></a>评论实现方式</h5><p>把评论和回复都当做评论，按时间排序。因为我们回复评论的情况较少，实现起来也比较简单。</p>
<h5 id="多线程评论数量不同步"><a href="#多线程评论数量不同步" class="headerlink" title="多线程评论数量不同步"></a>多线程评论数量不同步</h5><p>并发回复评论时，可能导致评论数显示不对，因此要加分布式锁。</p>
<p>我一开始使用的是sycronized锁，来实现单机的锁，这样可以不用管锁的获取和释放，挺方便的。后来因为使用了多个服务器，单机锁不适用了，后来想起来sycronized的轻量级锁，想想直接使用乐观锁的方式来实现也可以，利用mysql自己的行锁写锁，在更新操作的时候在where上多加一个条件，如果更新失败，就睡一下，然后重试。这种实现方式在高并发的时候效率并不高，因为如果出现同步问题的时候，锁是在数据库的，相当于在磁盘上，效率并不高。</p>
<p>使用了redis的<strong>分布式锁</strong>，原本打算用<strong>setnx</strong>做一个简单的分布式锁。考虑到可能出现客户端宕机，没有释放锁，导致死锁。于是加了<strong>过期时间</strong>。</p>
<p>通过记录当前的机器+线程id，避免把别人的锁给释放了。</p>
<p>锁过期了怎么解决？通过redission的watch dog机制，获取锁之后会将锁的线程放入到redission维护的一个map中，每隔10s检查一下，若还持有则会延长时间。</p>
<p>锁的释放可以手动释放也可以定期释放。</p>
<p>分布式锁可以确保在同一时刻只有一个用户对评论数进行更新，从而避免了数据竞争和不一致性。</p>
<h5 id="ElasticSearch全文搜索并高亮"><a href="#ElasticSearch全文搜索并高亮" class="headerlink" title="ElasticSearch全文搜索并高亮"></a>ElasticSearch全文搜索并高亮</h5><p>es类似于数据库，es中的索引表示数据库中的一个表，当新增数据时（比如帖子表），es会将其中的标题和内容写入到索引中，以便于搜索，对数据进行更新或者删除时，也会对索引中的数据进行处理。</p>
<p>当新建帖子时，会将帖子对象中的标题和内容字段异步写入到es中，这里首先是更新数据库，然后将内容写入消息字段，等待消费者将其写入es;如果es写入失败了，会再次加入到消息队列中。</p>
<p>当删除帖子时，会先删数据库，然后异步删除es中的内容，如果删除失败也是再加入消息队列。</p>
<p><strong>高亮的实现</strong>  重写elasticsearchtemplate类中的mapresults方法。 <strong>原理</strong>  在每一个关键字前后增加css样式</p>
<p><strong>es和redis底层都用的netty，这两者启动时会冲突，主要是es会检查netty是否初始化，解决方案通过系统设置es底层检查netty是否初始化的参数，设置为false</strong></p>
<h5 id="kafka实现系统通知"><a href="#kafka实现系统通知" class="headerlink" title="kafka实现系统通知"></a>kafka实现系统通知</h5><p>对于评论、点赞和关注三种通知，分别设置不同的topic，生产者线程只负责将这些行为写入到消息队列中，消费者线程会从消息队列中取出消息进行处理。</p>
<p>从业务层面来说，上面的行为封装成一个事件的实体类，让这个实体类内中封装消费者可能需要的数据，然后让实体类的对象作为消息（这里是将对象转为json字符串）写入到消息队列中去。消费者线程从消息队列中取出消息写入到数据库中，让系统通知到用户，进入通知界面，会对message表进行查询。</p>
<p>如果要实现实时的通知，则消费者线程从消息队列中取出消息后就直接通过websocket推送给前端。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jiangduwang.github.io/2024/04/02/%E7%AE%80%E5%8E%86%E5%85%AB%E8%82%A1%E5%86%85%E5%AE%B9/" data-id="clutj1iwu0002l8ul74j49fic" data-title="面试八股内容" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/02/hello-world/" class="article-date">
  <time class="dt-published" datetime="2024-04-02T08:02:56.852Z" itemprop="datePublished">2024-04-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/02/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jiangduwang.github.io/2024/04/02/hello-world/" data-id="clutj1iwo0000l8ul9bbu7xxh" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/06/03/%E7%BD%91%E7%BB%9C/">网络八股</a>
          </li>
        
          <li>
            <a href="/2024/06/03/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库八股</a>
          </li>
        
          <li>
            <a href="/2024/06/03/Java/">java八股</a>
          </li>
        
          <li>
            <a href="/2024/06/03/sql/">sql语句</a>
          </li>
        
          <li>
            <a href="/2024/06/03/kafka/">kafka八股</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 jiangduwang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>