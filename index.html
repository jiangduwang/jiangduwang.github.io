<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>顾涛的八股</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="顾涛的八股">
<meta property="og:url" content="https://jiangduwang.github.io/index.html">
<meta property="og:site_name" content="顾涛的八股">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="jiangduwang">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="顾涛的八股" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">顾涛的八股</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://jiangduwang.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-测试开发" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/10/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/" class="article-date">
  <time class="dt-published" datetime="2024-04-10T08:02:09.236Z" itemprop="datePublished">2024-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/10/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/">测试开发八股</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="测试的基本理论"><a href="#测试的基本理论" class="headerlink" title="测试的基本理论"></a>测试的基本理论</h2><h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><details>
<summary>展开查看</summary>

<p>又叫功能测试，功能测试在测试工作中占有比例最大。</p>
<p>测试人员不需要了解软件的内部结构，只关心输入和输出之间的关系是否符合预期。</p>
<p>无法保证软件代码内各主要路径都被覆盖到，导致测试不完全。</p>
</details>

<h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><details>
<summary>展开查看</summary>

<p>又叫结构测试</p>
<p>测试人员对软件的内部结构和工作原理有深入的了解，针对软件代码和路径进行测试。</p>
<p>软件代码改变，测试用例也需要改变。</p>
</details>

<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><details>
<summary>展开查看</summary>
描述输入实际值和预期输出行为或者结果的文档，同时也标识了测试过程结果与约束
</details>

<h2 id="如何理解测试开发中的开发"><a href="#如何理解测试开发中的开发" class="headerlink" title="如何理解测试开发中的开发"></a>如何理解测试开发中的开发</h2><details>
<summary>展开查看</summary>

<ol>
<li><strong>编写测试用例：</strong> 测试开发人员编写测试用例来验证软件系统的不同功能。这些测试用例可以是单元测试、集成测试、端到端测试等，覆盖不同层次和方面的功能和行为。</li>
<li><strong>编写自动化测试脚本：</strong> 测试开发人员使用编程语言（如Java、Python、JavaScript等）编写自动化测试脚本，用于执行测试用例并检查系统的响应和行为。这些脚本通常使用测试框架（如JUnit、TestNG、Selenium等）来组织和运行测试。</li>
<li><strong>开发测试工具和框架：</strong> 测试开发人员开发测试工具和框架，用于简化测试过程、提高测试效率和覆盖率。这些工具和框架可以包括测试数据生成工具、模拟器、Mock对象、测试管理系统等。</li>
<li><strong>维护测试代码：</strong> 随着软件系统的演变和变化，测试代码也需要不断更新和维护。测试开发人员负责确保测试代码的可靠性、稳定性和可维护性，以及及时更新测试代码以反映系统的变化。</li>
<li><strong>参与持续集成和持续部署：</strong> 测试开发人员参与持续集成和持续部署流程，确保每次代码提交或部署后都运行自动化测试，并及时发现和解决问题。</li>
</ol>
</details>

<h2 id="如何测试一个Java项目？"><a href="#如何测试一个Java项目？" class="headerlink" title="如何测试一个Java项目？"></a>如何测试一个Java项目？</h2><details>
<summary>展开查看</summary>

<ol>
<li><strong>单元测试：</strong> 编写单元测试来测试项目中的各个模块、类和方法。使用 JUnit 或 TestNG 等单元测试框架来编写测试用例，并确保覆盖尽可能多的代码路径和边界情况。</li>
<li><strong>集成测试：</strong> 编写集成测试来测试项目中不同模块之间的交互。这可以包括测试数据库访问、外部 API 调用、消息队列等。使用 JUnit、Mockito 等工具来模拟外部依赖，并编写集成测试用例。</li>
<li><strong>性能测试：</strong> 对项目进行性能测试，评估其在不同负载下的性能表现。使用 JMeter、Gatling 等性能测试工具来模拟大量用户请求，并监控系统的响应时间、吞吐量等指标。</li>
<li><strong>持续集成和持续部署：</strong> 将测试集成到持续集成和持续部署流程中，确保每次代码提交或部署后都运行测试，并及时发现和修复问题。</li>
</ol>
</details>

<h2 id="如果判断所写接口功能正常？"><a href="#如果判断所写接口功能正常？" class="headerlink" title="如果判断所写接口功能正常？"></a>如果判断所写接口功能正常？</h2><details>
<summary>展开查看</summary>

<ol>
<li><strong>功能测试：</strong> 确保接口按照预期工作。这包括发送各种有效和无效的输入数据，并验证接口的响应是否符合预期。例如，如果接口是一个登录接口，你可以测试使用正确的用户名和密码进行登录是否成功，以及使用错误的凭据时是否会得到适当的错误消息。</li>
<li><strong>性能测试：</strong> 检查接口的性能，包括响应时间、吞吐量等指标。确保接口在负载增加时仍然能够正常工作，并且性能不会严重下降。</li>
<li><strong>安全测试：</strong> 确保接口受到适当的安全保护，例如输入验证、防止SQL注入、XSS攻击等。</li>
<li><strong>兼容性测试：</strong> 确保接口在不同的浏览器、操作系统和设备上都能正常工作。</li>
</ol>
</details>

<h2 id="怎么构造无用测试用例？"><a href="#怎么构造无用测试用例？" class="headerlink" title="怎么构造无用测试用例？"></a>怎么构造无用测试用例？</h2><details>
<summary>展开查看</summary>

<ol>
<li><strong>随机数据：</strong> 使用随机生成的数据作为输入。这些数据可能不符合业务逻辑或实际情况，从而导致测试用例的无用性。</li>
<li><strong>非法输入：</strong> 提供完全不合法的输入数据。例如，如果一个字段要求输入数字，你可以提供字母字符或特殊字符。</li>
<li><strong>重复数据：</strong> 重复使用相同的数据进行测试，而不关注不同数据情况下的行为。这样做可能会错过一些潜在的问题。</li>
</ol>
</details>

<h2 id="如何感知线上项目出现问题"><a href="#如何感知线上项目出现问题" class="headerlink" title="如何感知线上项目出现问题"></a>如何感知线上项目出现问题</h2><details>
<summary>展开查看</summary>

<ol>
<li><strong>日志监控：</strong> 实时监控系统的日志以捕获异常情况和错误信息。通过设置适当的日志级别和使用日志聚合工具，可以帮助发现潜在的问题。</li>
<li><strong>性能监控：</strong> 监控系统的性能指标，如响应时间、吞吐量、CPU 使用率、内存使用率等。突然的性能下降可能是系统出现问题的迹象。</li>
<li><strong>自动化测试：</strong> 编写自动化测试用例，定期运行以确保系统的功能和性能符合预期。自动化测试可以在每次部署后运行，帮助发现新的问题。</li>
</ol>
</details>

<h2 id="小红书购物搜索框设计测试用例"><a href="#小红书购物搜索框设计测试用例" class="headerlink" title="小红书购物搜索框设计测试用例"></a>小红书购物搜索框设计测试用例</h2><details>
<summary>展开查看</summary>

<p><strong>测试用例名称：搜索框输入有效关键词</strong></p>
<ul>
<li>输入：在搜索框中输入有效的商品关键词，例如“连衣裙”。</li>
<li>操作：点击搜索按钮或按下回车键。</li>
<li>预期结果：搜索结果页面显示与输入关键词相关的商品列表。</li>
</ul>
<p><strong>测试用例名称：搜索框输入无效关键词</strong></p>
<ul>
<li>输入：在搜索框中输入无效的商品关键词，例如“@@@”。</li>
<li>操作：点击搜索按钮或按下回车键。</li>
<li>预期结果：搜索结果页面提示“未找到相关商品”。</li>
</ul>
<p><strong>测试用例名称：搜索框输入空关键词</strong></p>
<ul>
<li>输入：在搜索框中不输入任何内容。</li>
<li>操作：点击搜索按钮或按下回车键。</li>
<li>预期结果：搜索结果页面显示全部商品列表。</li>
</ul>
<p><strong>测试用例名称：搜索框联想功能</strong></p>
<ul>
<li>输入：在搜索框中输入部分关键词，例如“连衣”。</li>
<li>操作：等待几秒钟，观察搜索框下方是否出现联想词。</li>
<li>预期结果：搜索框下方显示与输入关键词相关的联想词列表。</li>
</ul>
<p><strong>测试用例名称：搜索框输入并选择联想词</strong></p>
<ul>
<li>输入：在搜索框中输入部分关键词，例如“连衣”。</li>
<li>操作：从联想词列表中选择一个词，例如“连衣裙”。</li>
<li>预期结果：搜索框中显示选择的联想词，并跳转到与该词相关的搜索结果页面。</li>
</ul>
<p><strong>测试用例名称：搜索框清空功能</strong></p>
<ul>
<li>输入：在搜索框中输入关键词，例如“连衣裙”。</li>
<li>操作：点击搜索框右侧的清空按钮。</li>
<li>预期结果：搜索框中的文本被清空，搜索框恢复为空状态。</li>
</ul>
</details>

<h2 id="登录设计测试样例"><a href="#登录设计测试样例" class="headerlink" title="登录设计测试样例"></a>登录设计测试样例</h2><details>
<summary>展开查看</summary>

<ol>
<li><strong>测试用例名称：输入有效的用户名和密码登录</strong><ul>
<li>输入：有效的用户名和密码。</li>
<li>操作：在登录页面输入用户名和密码，点击登录按钮。</li>
<li>预期结果：成功登录，跳转到用户的个人资料页面或首页。</li>
</ul>
</li>
<li><strong>测试用例名称：输入无效的用户名和密码登录</strong><ul>
<li>输入：无效的用户名和密码。</li>
<li>操作：在登录页面输入错误的用户名和密码，点击登录按钮。</li>
<li>预期结果：登录失败，提示用户名或密码错误的错误信息。</li>
</ul>
</li>
<li><strong>测试用例名称：输入不存在的用户名登录</strong><ul>
<li>输入：不存在的用户名和有效密码。</li>
<li>操作：在登录页面输入不存在的用户名和有效密码，点击登录按钮。</li>
<li>预期结果：登录失败，提示用户名不存在的错误信息。</li>
</ul>
</li>
<li><strong>测试用例名称：输入正确的用户名和空密码登录</strong><ul>
<li>输入：有效的用户名和空密码。</li>
<li>操作：在登录页面输入正确的用户名和空密码，点击登录按钮。</li>
<li>预期结果：登录失败，提示密码不能为空的错误信息。</li>
</ul>
</li>
<li><strong>测试用例名称：输入空用户名和正确密码登录</strong><ul>
<li>输入：空用户名和有效的密码。</li>
<li>操作：在登录页面输入空用户名和正确的密码，点击登录按钮。</li>
<li>预期结果：登录失败，提示用户名不能为空的错误信息。</li>
</ul>
</li>
<li><strong>测试用例名称：输入特殊字符的用户名和密码登录</strong><ul>
<li>输入：包含特殊字符的用户名和密码。</li>
<li>操作：在登录页面输入包含特殊字符的用户名和密码，点击登录按钮。</li>
<li>预期结果：登录失败，提示用户名或密码格式不正确的错误信息。</li>
</ul>
</li>
<li><strong>测试用例名称：记住登录状态</strong><ul>
<li>输入：有效的用户名和密码。</li>
<li>操作：在登录页面勾选“记住我”选项后登录。</li>
<li>预期结果：成功登录后，关闭浏览器再次打开时，应自动保持登录状态，无需重新输入用户名和密码。</li>
</ul>
</li>
<li><strong>测试用例名称：登录页链接验证</strong><ul>
<li>输入：无。</li>
<li>操作：检查登录页面上的链接。</li>
<li>预期结果：登录页面应包含“忘记密码”、“注册账号”等相关链接，确保用户可以方便地进行其他操作。</li>
</ul>
</li>
<li><strong>测试用例名称：跳转到登录页面</strong><ul>
<li>输入：未登录状态。</li>
<li>操作：尝试访问需要登录权限的页面。</li>
<li>预期结果：跳转到登录页面，并在登录成功后自动跳回原页面。</li>
</ul>
</li>
<li><strong>测试用例名称：登录界面的响应速度</strong><ul>
<li>输入：无。</li>
<li>操作：在不同网络环境下打开登录页面。</li>
<li>预期结果：登录页面应该在合理的时间内加载完成，不应该出现过长的加载时间。</li>
</ul>
</li>
</ol>
</details>

<h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><details>
<summary>展开查看</summary>

<p>以人为驱动的测试行为转化为机器执行的一种过程</p>
<p>自动化测试包括UI测试、接口测试和单元测试</p>
<p><strong>Selenium</strong>——UI自动化测试工具，工作原理：</p>
<ol>
<li>开发人员编写自动化脚本代码（测试代码）</li>
<li>测试代码通过Web驱动程序（如ChromeDriver、GeckoDriver等）与所选浏览器建立通信</li>
<li>Web驱动程序将命令发送给浏览器，并接收来自浏览器的响应。</li>
<li>浏览器执行接收到的命令，例如导航至指定URL、查找和操作页面上的元素等。</li>
<li>浏览器将执行结果返回给Web驱动程序。</li>
<li>Web驱动程序将结果传递给测试代码，以便进行进一步的处理和验证。</li>
</ol>
<p><img src="https://developer.qcloudimg.com/http-save/yehe-10496291/a66e29500026a19ea096b11bf8bae1f8.png" alt="img"></p>
</details>

<h2 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h2><details>
<summary>展开查看</summary>

<ol>
<li><strong>JUnit</strong>：JUnit是Java中最流行的单元测试框架之一，用于编写和运行单元测试。它提供了一组注解和断言方法，使得编写测试用例变得简单易懂。</li>
<li><strong>TestNG</strong>：TestNG是另一个流行的Java测试框架，提供了比JUnit更丰富的功能，例如参数化测试、测试组、依赖测试等。它也可以用于编写单元测试和集成测试。</li>
<li><strong>Selenium</strong>：Selenium是用于自动化Web应用程序测试的工具，它支持多种浏览器，并提供了Java API，使得测试脚本的编写和执行变得简单。Selenium可以用于执行功能测试、回归测试等。</li>
<li><strong>JMeter</strong>：JMeter是一个用于性能测试的工具，它可以模拟大量用户并测量应用程序的性能和稳定性。JMeter也可以用于功能测试和接口测试。</li>
</ol>
</details>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://jiangduwang.github.io/2024/04/10/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/" data-id="clutj1iws0001l8ul99efduqk" data-title="测试开发八股" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-简历八股内容" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/02/%E7%AE%80%E5%8E%86%E5%85%AB%E8%82%A1%E5%86%85%E5%AE%B9/" class="article-date">
  <time class="dt-published" datetime="2024-04-02T10:28:05.019Z" itemprop="datePublished">2024-04-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/02/%E7%AE%80%E5%8E%86%E5%85%AB%E8%82%A1%E5%86%85%E5%AE%B9/">面试八股内容</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>面试官下午好，我叫顾涛，是一名南京理工大学的硕士研究生，专业是计算机科学与技术。在校期间，我参与了多个研究所的实习项目，主要是参与巡逻无人车车内软件的开发；然后Java是参与完成了MTR课表小程序，主要是帮南理工的同学们快捷查询课表、成绩等教务信息，以及实现一个校内学生交流的平台。</p>
<h2 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h2><h3 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h3><h4 id="HashMap-与-ConcurrentHashMap-的实现原理是怎样的？ConcurrentHashMap-是如何保证线程安全的？"><a href="#HashMap-与-ConcurrentHashMap-的实现原理是怎样的？ConcurrentHashMap-是如何保证线程安全的？" class="headerlink" title="HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？"></a>HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？</h4><p>（hashmap1.7和1.8的区别）</p>
<details>
<summary>展开查看</summary>

<ul>
<li>hashmap1.8之前数组和链表结合在一起使用（拉链法），哈希冲突将元素加入到链表中，1.7采用的是头插法。1.8及以后，默认长度为16，当负载因子大于0.75时会扩充数组（每次扩容一倍，移位操作，效率比较高），链表长度大于8，如果数组长度不大于64会扩充数组，否则会转化为红黑树，1.8采用的是尾插法。<strong>每次扩充都会rehash</strong>。</li>
<li>concurrenthashmap在1.7由多个segment组成，一个segment相当于一个hashmap，每一个segment用一个锁，segment最大长度16；1.8之后减少了悲观锁的使用，会先尝试自旋+CAS方式加入元素，尝试多次不成功才通过synchronized锁。底层也是由数组+链表变为数组+红黑树。</li>
</ul>
</details>

<h4 id="为什么1-8的哈希表加入元素改用尾插法"><a href="#为什么1-8的哈希表加入元素改用尾插法" class="headerlink" title="为什么1.8的哈希表加入元素改用尾插法"></a>为什么1.8的哈希表加入元素改用尾插法</h4><details>
<summary>展开查看</summary>

<p>1.8之前，hashmap采用的是头插法，是考虑到新插入的数据可能作为热点数据使用，放在头部可以减少查找时间；</p>
<p>1.8之后采用的是尾插法，为的是防止在多线程环境下出现<strong>环化</strong>。</p>
<p>多线程下头插法出现环化的问题：假设两个线程分别都插入一个数据A和B，前一个线程在准备插入时时间片用完，第二个线程进行扩容，因为是头插法，因此数据顺序是BA，但此时第一个线程的cur指针指向A，next指针指向B，它会先移动A，然后cur指针移向B，再插入B，由于第二个线程的next的指针的下一个next指针还是指向A，第一个线程还会再插入一次A，这样ABA，出现环化。</p>
</details>

<h4 id="简述-ArrayList-与-LinkedList-的底层实现以及常见操作的时间复杂度"><a href="#简述-ArrayList-与-LinkedList-的底层实现以及常见操作的时间复杂度" class="headerlink" title="简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度"></a>简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度</h4><details>
<summary>展开查看</summary>

<ul>
<li>arraylist底层实现就是一个初始容量10构造的空数组，尾部插入和删除时间复杂度O(1)，其余操作都是O(n)</li>
<li>linkedlist底层实现是一个双向链表，首尾插入和删除时间复杂度O(1)，其余操作都是O(n)</li>
</ul>
</details>

<h4 id="hashcode和equals方法的联系"><a href="#hashcode和equals方法的联系" class="headerlink" title="hashcode和equals方法的联系"></a>hashcode和equals方法的联系</h4><details>
<summary>展开查看</summary>

<p>当两个对象的哈希码相同且equals为true时，表明两个对象相等。</p>
<p>重写equals方法必须要重写hashcode方法，避免hashcode不相等而equals相等的情况。</p>
</details>

<h4 id="和equals有什么区别"><a href="#和equals有什么区别" class="headerlink" title="&#x3D;&#x3D;和equals有什么区别"></a>&#x3D;&#x3D;和equals有什么区别</h4><details>
<summary>展开查看</summary>

<p>&#x3D;&#x3D;对比非引用变量直接比值，引用变量比较地址值</p>
<p>原object的equals对比两个对象的地址值，经过重写后基本都对比真正的值，比如string</p>
</details>

<h4 id="浅拷贝、深拷贝、引用拷贝"><a href="#浅拷贝、深拷贝、引用拷贝" class="headerlink" title="浅拷贝、深拷贝、引用拷贝"></a>浅拷贝、深拷贝、引用拷贝</h4><details>
<summary>展开查看</summary>

<ul>
<li>浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li>
<li>深拷贝完全复制整个对象，包括这个对象包含的内部对象</li>
<li>引用拷贝是两个不同的引用指向同一个对象</li>
</ul>
</details>

<h4 id="什么是重写和重载"><a href="#什么是重写和重载" class="headerlink" title="什么是重写和重载"></a>什么是重写和重载</h4><details>
<summary>展开查看</summary>

<p>重载是指方法名相同，返回值、参数列表都可以不相同，比如构造函数；</p>
<p>重写是子类对父类已有的方法进行覆盖，参数列表必须相同。</p>
</details>

<h4 id="java中final的作用"><a href="#java中final的作用" class="headerlink" title="java中final的作用"></a>java中final的作用</h4><details>
<summary>展开查看</summary>

<p>对于变量，表明该变量的值不能被修改；对于方法，表示子类不能重写final修饰的父类的方法；对于类，则该类不能被继承。</p>
</details>

<h4 id="hashset实现原理"><a href="#hashset实现原理" class="headerlink" title="hashset实现原理"></a>hashset实现原理</h4><details>
<summary>展开查看</summary>

<p>底层是hashmap，调用add实际上就是调用hashmap的put方法</p>
</details>

<h4 id="装饰者模式和适配器模式"><a href="#装饰者模式和适配器模式" class="headerlink" title="装饰者模式和适配器模式"></a>装饰者模式和适配器模式</h4><details>
<summary>展开查看</summary>

<ul>
<li>装饰者模式是指在不改变原有功能的前提下增强功能，有点类似AOP，比如FlieInputStream和InputStream类</li>
<li>适配器模式是指让接口不兼容而不能交互的类可以一起工作，比如InputStreamReader可以将字节流转为字符流</li>
</ul>
</details>

<h4 id="BIO-NIO-AIO"><a href="#BIO-NIO-AIO" class="headerlink" title="BIO  NIO AIO"></a>BIO  NIO AIO</h4><details>
<summary>展开查看</summary>

<p>BIO<strong>阻塞同步IO模型</strong></p>
<p>NIO分为两种，一种会一直<strong>轮询</strong>直到调用，一种是<strong>多路复用</strong>，先发起select调用，询问是否准备就绪了，准备就绪了就会调用</p>
<p>AIO <strong>异步IO模型</strong></p>
</details>

<h4 id="java出现OOM的情况"><a href="#java出现OOM的情况" class="headerlink" title="java出现OOM的情况"></a>java出现OOM的情况</h4><details>
<summary>展开查看</summary>

<ul>
<li>创建了太多对象</li>
<li>创建了太大的对象，比如数组开的太大</li>
<li>创建了大量的字符串常量</li>
</ul>
</details>

<h3 id="java的内存区域与垃圾回收机制"><a href="#java的内存区域与垃圾回收机制" class="headerlink" title="java的内存区域与垃圾回收机制"></a>java的内存区域与垃圾回收机制</h3><h4 id="Java-中垃圾回收机制中如何判断对象需要回收？常见的-GC-回收算法有哪些？"><a href="#Java-中垃圾回收机制中如何判断对象需要回收？常见的-GC-回收算法有哪些？" class="headerlink" title="Java 中垃圾回收机制中如何判断对象需要回收？常见的 GC 回收算法有哪些？"></a>Java 中垃圾回收机制中如何判断对象需要回收？常见的 GC 回收算法有哪些？</h4><details>
<summary>展开查看</summary>

<ul>
<li>有两种方法：一种是<strong>引用计数法</strong>，计算每个对象的被引用次数，若为0，则需要回收，但有可能需要循环引用的情况；还有一种<strong>可达性分析</strong>，从gc根节点向下搜索，若不可达，则回收这个对象。</li>
<li>标记-清除、复制、标记-整理，新生代一般使用复制算法（应用：两个survivor区），老生代标记-清除</li>
</ul>
</details>

<h4 id="JVM内存分类"><a href="#JVM内存分类" class="headerlink" title="JVM内存分类"></a>JVM内存分类</h4><details>
<summary>展开查看</summary>

<ul>
<li>堆内存：几乎所有对象实例和<strong>字符串常量池</strong>都会放在堆上，同时堆也是gc管理的主要区域，也叫gc堆</li>
<li>栈内存：主要存临时变量和对象引用</li>
<li>本地内存：包含元空间（永久代 ），元空间就是方法区的实现，存放了<strong>常量池</strong>。</li>
</ul>
</details>

<h4 id="Java-类的加载流程是怎样的？什么是双亲委派机制？"><a href="#Java-类的加载流程是怎样的？什么是双亲委派机制？" class="headerlink" title="Java 类的加载流程是怎样的？什么是双亲委派机制？"></a>Java 类的加载流程是怎样的？什么是双亲委派机制？</h4><details>
<summary>展开查看</summary>

<ul>
<li>加载——链接（验证——准备——解析）——初始化</li>
<li>类加载器实例在亲自查找类和资源之前，会将这个任务委托给父类加载器。</li>
</ul>
</details>

<h4 id="简述-CMS-与-G1-机制的区别"><a href="#简述-CMS-与-G1-机制的区别" class="headerlink" title="简述 CMS 与 G1 机制的区别"></a>简述 CMS 与 G1 机制的区别</h4><details>
<summary>展开查看</summary>

<p>cms一款并发垃圾收集器，实现了让<strong>垃圾收集线程</strong>和<strong>用户线程</strong>同时工作。</p>
<ul>
<li>CMS主要设计目的是<strong>减少垃圾回收的停顿时间</strong>，G1是提供<strong>可预测的停顿时间</strong>，同时兼顾吞吐量和停顿时间。</li>
<li>CMS通过并发标记和并发清除来收集垃圾对象，G1通过<strong>划分内存区域</strong>和<strong>优先级排序</strong>，再通过并发标记来实现目标。</li>
</ul>
</details>

<h4 id="新生代设计两个survivor区的目的是什么"><a href="#新生代设计两个survivor区的目的是什么" class="headerlink" title="新生代设计两个survivor区的目的是什么"></a>新生代设计两个survivor区的目的是什么</h4><details>
<summary>展开查看</summary>

<p>如果只有一个survivor区的话，由于survivor区中也有死亡的对象，这样survivor区就出现了内存碎片，然而survivor区还有很多对象年龄还没有到，不能清理survivor区中的对象到老年代中。</p>
<p>有两个survivor区的话，相当于标记-复制算法，当Eden区满了之后会触发一次minor gc，将Eden区和s0区中存活的对象都写入s1区中，为了避免不断地在两个s区之间复制对象，此时将空的s0区作为原来的s1区使用。</p>
<p><strong>有效避免内存碎片化</strong></p>
</details>

<h3 id="java并发编程"><a href="#java并发编程" class="headerlink" title="java并发编程"></a>java并发编程</h3><h4 id="Synchronized-关键字底层是如何实现的？它与-Lock-相比优缺点分别是什么？"><a href="#Synchronized-关键字底层是如何实现的？它与-Lock-相比优缺点分别是什么？" class="headerlink" title="Synchronized 关键字底层是如何实现的？它与 Lock 相比优缺点分别是什么？"></a>Synchronized 关键字底层是如何实现的？它与 Lock 相比优缺点分别是什么？</h4><details>
<summary>展开查看</summary>

<ul>
<li>底层是通过同步代码块实现，1个monitorenter指令指向同步代码块的开始位置，两个monitorexit指向结束位置</li>
<li>优点：使用简单；synchronized依赖于jvm，可以得到jvm层面的优化； 缺点：没有lock灵活，功能没有lock丰富。</li>
</ul>
</details>

<h4 id="Java-的线程有哪些状态，转换关系是怎么样的？"><a href="#Java-的线程有哪些状态，转换关系是怎么样的？" class="headerlink" title="Java 的线程有哪些状态，转换关系是怎么样的？"></a>Java 的线程有哪些状态，转换关系是怎么样的？</h4><details>
<summary>展开查看</summary>

<p>新建、运行、等待、阻塞、终止。</p>
<p>线程创建之后，调用start方法线程等待运行；调用wait方法，等待某些条件、资源的满足；<strong>悲观锁阻塞，等待锁释放</strong>；线程完成或异常终止。</p>
</details>

<h4 id="JMM-中内存模型是怎样的？什么是指令序列重排序？"><a href="#JMM-中内存模型是怎样的？什么是指令序列重排序？" class="headerlink" title="JMM 中内存模型是怎样的？什么是指令序列重排序？"></a>JMM 中内存模型是怎样的？什么是指令序列重排序？</h4><details>
<summary>展开查看</summary>

<ul>
<li>内存模型是Java中多线程并发访问共享内存的规则和保证，具体工作方式是线程的共享变量必须存储在主内存中，每个线程中都有一个私有的本地内存，线程对共享变量的修改都是现在私有本地内存中修改，再更新到主内存中。</li>
<li>在不改变程序执行结果的前提下，JVM会重新调整指令的执行顺序以提升执行效率。</li>
</ul>
</details>

<h4 id="volatile-关键字解决了什么问题，它的实现原理是什么？"><a href="#volatile-关键字解决了什么问题，它的实现原理是什么？" class="headerlink" title="volatile 关键字解决了什么问题，它的实现原理是什么？"></a>volatile 关键字解决了什么问题，它的实现原理是什么？</h4><details>
<summary>展开查看</summary>

<p>保证了变量的可见性，每次修改volatile修饰的变量都需要进入主存中读取；可以防止JVM指令重排序（通过内存屏障实现）。</p>
</details>

<h4 id="简述-CAS-原理，什么是-ABA-问题，怎么解决？"><a href="#简述-CAS-原理，什么是-ABA-问题，怎么解决？" class="headerlink" title="简述 CAS 原理，什么是 ABA 问题，怎么解决？"></a>简述 CAS 原理，什么是 ABA 问题，怎么解决？</h4><details>
<summary>展开查看</summary>

<ul>
<li>乐观锁compare and swap      当更新的值和预期值相等时，对数据进行更新</li>
<li>aba问题是在比对更新值和预期值，中间经历了几次更新，但是最终的更新值还是等于预期值。   解决：CAS+版本号机制或时间戳</li>
</ul>
</details>

<h4 id="CAS除了ABA问题还有哪些问题？"><a href="#CAS除了ABA问题还有哪些问题？" class="headerlink" title="CAS除了ABA问题还有哪些问题？"></a>CAS除了ABA问题还有哪些问题？</h4><details>
<summary>展开查看</summary>

<ul>
<li>循环时间长开销大  CAS通过自旋操作不断重试</li>
<li>只能保证一个共享变量的原子操作   CAS只对一个共享变量有效。</li>
</ul>
</details>

<h4 id="线程池是如何实现的？简述线程池的任务策略"><a href="#线程池是如何实现的？简述线程池的任务策略" class="headerlink" title="线程池是如何实现的？简述线程池的任务策略"></a>线程池是如何实现的？简述线程池的任务策略</h4><details>
<summary>展开查看</summary>

<ul>
<li>通过ThreadPoolExecutor构造函数可以创建多种类型的线程池，包括固定线程线程池、单线程线程池、cache线程池等</li>
<li>任务策略即饱和策略，默认策略是抛出异常拒绝新来的任务；或者把任务退回给调用者线程，让调用者线程来执行这个任务；或者丢弃掉最早未处理的任务</li>
</ul>
</details>

<h4 id="ThreadLocal-实现原理是什么？"><a href="#ThreadLocal-实现原理是什么？" class="headerlink" title="ThreadLocal 实现原理是什么？"></a>ThreadLocal 实现原理是什么？</h4><details>
<summary>展开查看</summary>

<p>threadlocal会保存变量的本地副本，使其独属于这个线程。本质上是一个threadlocalmap，键为threadlocal对象，值为副本的值，调用threadlocal的put和get方法本质上就是调用threadlocalmap的put和get方法</p>
</details>

<h4 id="Java锁升级机制"><a href="#Java锁升级机制" class="headerlink" title="Java锁升级机制"></a>Java锁升级机制</h4><details>
<summary>展开查看</summary>

<p>锁升级是从偏向锁到轻量级锁，再到重量级锁的过程，由jvm运行时决定。</p>
<p>偏向锁会偏向第一次被加锁的对象，轻量级锁指有另一个线程尝试获取锁，偏向锁会升级成轻量级锁，会通过自旋等待获取锁；当自旋等待获取不到锁，会升级到重量级锁，重量级锁就是排他锁。</p>
<p>自旋：线程等待的方式，不会让线程进入阻塞状态，不断重试直至满足条件</p>
</details>

<h4 id="什么是公平锁？什么是非公平锁？"><a href="#什么是公平锁？什么是非公平锁？" class="headerlink" title="什么是公平锁？什么是非公平锁？"></a>什么是公平锁？什么是非公平锁？</h4><details>
<summary>展开查看</summary>

<p>公平锁表示获取锁的顺序按照请求的顺序来分配，FIFO</p>
<p>非公平锁不一定按照请求的顺序。</p>
<p>synchronized非公平锁，reentrantlock默认非公平锁，可以设置公平锁（基于JDK，通过构造函数设置）。</p>
</details>

<h4 id="可重入锁的实现原理"><a href="#可重入锁的实现原理" class="headerlink" title="可重入锁的实现原理"></a>可重入锁的实现原理</h4><details>
<summary>展开查看</summary>

<p>为每个锁维护一个<strong>拥有者线程标识</strong>和<strong>计数器</strong>，在加锁和解锁操作时对计数器进行递增和递减，并通过并发控制确保线程对锁状态的访问是安全的。</p>
<p>如ReentrantLock，在内部维护了一个锁状态变量和一个等待队列，等待队列会阻塞等待获取锁的线程。在获取锁的时候，会判断当前锁状态变量是否为0，如果为0，则获取到锁，且锁状态变量+1，这时其他锁线程无法获取到锁，当获取锁的同一个线程再次获取锁时，则锁状态变量会再加一。当锁状态变量变为0才会真正释放锁。</p>
</details>

<h3 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h3><h4 id="常见的面向对象设计的设计模式"><a href="#常见的面向对象设计的设计模式" class="headerlink" title="常见的面向对象设计的设计模式"></a>常见的面向对象设计的设计模式</h4><details>
<summary>展开查看</summary>

<p>工厂模式和单例模式，工厂模式通过封装对象的创建过程降低耦合度。单例模式适合只需要创建一次的对象，比如线程池，日志对象。</p>
<p><strong>单例模式的实现</strong>   私有构造函数，通过volatile关键字定义单例，避免指令重排序，采用双重校验锁保证单例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//注意这里是对类对象加锁，不是对单例对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</details>

<h4 id="spring中的单例bean是线程安全的吗"><a href="#spring中的单例bean是线程安全的吗" class="headerlink" title="spring中的单例bean是线程安全的吗"></a>spring中的单例bean是线程安全的吗</h4><details>
<summary>展开查看</summary>

<p>spring中的bean默认是单例模式，可以修改为多例模式。</p>
<p><strong>spring中的单例bean不是线程安全的，</strong>一般情况下spring的bean都是注入无状态的对象，没有线程安全问题；但是如果在bean中定义了可修改的变量，线程就不安全了，要靠多例模式或者加锁来实现线程安全。</p>
<p>线程不安全的例子：项目中设置一个计数器服务，创建一个bean来记录。</p>
</details>

<h4 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h4><details>
<summary>展开查看</summary>

<p>在运行时可以分析类以及执行类中的方法，通过反射可以获取类中的所有属性和方法</p>
</details>

<h4 id="IOC和AOP"><a href="#IOC和AOP" class="headerlink" title="IOC和AOP"></a>IOC和AOP</h4><details>
<summary>展开查看</summary>

<ul>
<li>IOC控制反转，对象的创建和调用控制交给容器来实现，具体是依赖注入。通过<strong>工厂模式</strong>负责对象的创建和管理。</li>
<li>AOP面向切面编程：代理模式（通过反射实现），通过代理对象实现对目标方法的增强。静态代理，定义一个真实类和一个代理类实现接口，将真实对象注入到代理类中；动态代理分为jdk动态代理和CGLIB动态代理，jdk动态代理只能代理实现了接口的类或直接代理接口，cglib可以代理未实现任何接口的类，它生成一个被代理类的子类来拦截被代理类的方法调用</li>
</ul>
<p><strong>AOP的应用</strong>  记录操作日志、Spring中内置的事务处理（<strong>声明式事务管理</strong>    通过环绕通知捕捉异常实现事务的执行或者回滚）</p>
</details>

<h4 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h4><details>
<summary>展开查看</summary>

<p>BeanDefinition（获取bean的定义信息）——&gt; 对象的创建（构造函数，创建空对象） ——&gt;对象方法的创建（依赖注入：注入属性和值）</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240325145435343.png" alt="image-20240325145435343"></p>
</details>

<h4 id="spring如何解决循环依赖的问题"><a href="#spring如何解决循环依赖的问题" class="headerlink" title="spring如何解决循环依赖的问题"></a>spring如何解决循环依赖的问题</h4><details>
<summary>展开查看</summary>

<p>Spring通过使用三级缓存来解决循环依赖问题。<strong>bean的创建分为两步：对象的实例化和对象属性的实例化</strong>  未对象属性实例化的对象称为半成品对象</p>
<p>一级缓存存储已完全初始化的对象，二级缓存存储半成品对象，三级缓存只是对象的创建委托。</p>
<p>spring中的循环依赖对象的创建过程：</p>
<ol>
<li>A创建过程中依赖B，则A进入三级缓存中，再去实例化B</li>
<li>B创建过程中依赖A，则查找缓存中是否有A，发现三级缓存中有A，则将A放入二级缓存中，并删除三级缓存中的A。</li>
<li>B创建完成，将B放入一级缓存中，此时A还是半成品对象，然后继续创建A，A依赖B，这时去查缓存，发现B在一级缓存中，直接取B完成创建，最后完成创建A，将A放入一级缓存中。</li>
</ol>
</details>

<h4 id="springMVC的执行流程"><a href="#springMVC的执行流程" class="headerlink" title="springMVC的执行流程"></a>springMVC的执行流程</h4><details>
<summary>展开查看</summary>

<ol>
<li>用户发出请求到前端控制器</li>
<li>前端控制器收到请求调用处理器映射器</li>
<li>处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器，再一起返回给前端控制器；</li>
<li>前端控制器调用处理器适配器，处理器适配器经过适配调用具体的处理器</li>
<li>在方法上添加了@ResponseBody，通过HttpMessageConverter来返回结果转换为JSON并响应。</li>
</ol>
</details>

<h4 id="springboot自动配置原理"><a href="#springboot自动配置原理" class="headerlink" title="springboot自动配置原理"></a>springboot自动配置原理</h4><details>
<summary>展开查看</summary>

<ol>
<li>springboot项目的入口类上有一个注解@SpringBootApplication，这个注解包含3个注解，分别为@SpringBootConfiguration、@EnableAutoConfiguation和@ComponentScan</li>
<li><strong>@EnableAutoConfiguation</strong>实现自动化配置的核心注解，该注解通过@Import注解导入对应的配置选择器。所有的自动配置类都会在“META-INF&#x2F;spring.factories”文件中，位于对应的自动配置jar包中。</li>
<li>@ConditionalOnClass注解会判断是否有对应的class文件，如果有则加载该类，将该类的bean放入spring容器中。</li>
</ol>
</details>

<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="MySQL-为什么使用-B-树来作索引，对比-B-树它的优点和缺点是什么？"><a href="#MySQL-为什么使用-B-树来作索引，对比-B-树它的优点和缺点是什么？" class="headerlink" title="MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么？"></a>MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么？</h4><details>
<summary>展开查看</summary>

<p>B+树相比于B树有几个显著的优点：B+树具备更少的IO次数（非叶子节点只存储索引），更稳定的查询效率（只搜索叶子节点），B+树的所有叶子节点构成一个有序链表，更适用于范围查找。  </p>
<p>缺点就是需要维护叶子节点之间的指针</p>
</details>

<h4 id="简述乐观锁以及悲观锁的区别以及使用场景"><a href="#简述乐观锁以及悲观锁的区别以及使用场景" class="headerlink" title="简述乐观锁以及悲观锁的区别以及使用场景"></a>简述乐观锁以及悲观锁的区别以及使用场景</h4><details>
<summary>展开查看</summary>

<p>乐观锁假设不会出现并发问题，不限制线程对数据进行更新，在提交修改时会验证是否被修改了。mysql事务并发控制中使用的是MVCC，适用于读比较多的场景。</p>
<p>悲观锁则每次在获取资源时都会上锁，直到处理完。mysql中直接就叫做锁，适用于写比较多的场景</p>
</details>

<h4 id="简述-MySQL-常见索引类型，介绍一下覆盖索引"><a href="#简述-MySQL-常见索引类型，介绍一下覆盖索引" class="headerlink" title="简述 MySQL 常见索引类型，介绍一下覆盖索引"></a>简述 MySQL 常见索引类型，介绍一下覆盖索引</h4><details>
<summary>展开查看</summary>

<p>（聚簇索引和非聚簇索引有什么区别？）</p>
<p>聚簇索引：索引结构和数据一起存放，如InnoDB的B+树</p>
<p>非聚簇索引：索引结构和数据分开存放，如MyISAM的B+树</p>
<p>覆盖索引：索引包含所有需要查询的字段，这样在查询时可以直接从索引中获取数据，不需要查表</p>
<p>联合索引：使用表中的多个字段创建索引         最左前缀匹配原则</p>
</details>

<h4 id="简述事务的四大特性"><a href="#简述事务的四大特性" class="headerlink" title="简述事务的四大特性"></a>简述事务的四大特性</h4><details>
<summary>展开查看</summary>

<p>ACID  原子性：指令要么全部成功，要么全部失败；隔离性：一个用户的事务不会被其他事务干扰；持久性：数据的改变是持久的，即使数据库发生故障也能恢复；一致性：执行事务前后，数据保持一致</p>
</details>

<h4 id="MySQL-有哪些常见的存储引擎？它们的区别是什么"><a href="#MySQL-有哪些常见的存储引擎？它们的区别是什么" class="headerlink" title="MySQL 有哪些常见的存储引擎？它们的区别是什么"></a>MySQL 有哪些常见的存储引擎？它们的区别是什么</h4><details>
<summary>展开查看</summary>

<p>（什么是数据库事务，MySQL 为什么会使用 InnoDB 作为默认选项）</p>
<p>（MySQL中 InnoDB 和 MylSAM 的区别是什么？）</p>
<p>InnoDB：支持行级锁，事务型的存储引擎，支持数据库崩溃后的安全恢复，索引类型是聚簇索引</p>
<p>MyISAM：只支持表级锁，不支持事务，不支持数据库崩溃后的安全恢复，索引类型是非聚簇索引</p>
</details>

<h4 id="数据库的事务隔离级别有哪些？各有哪些优缺点？"><a href="#数据库的事务隔离级别有哪些？各有哪些优缺点？" class="headerlink" title="数据库的事务隔离级别有哪些？各有哪些优缺点？"></a>数据库的事务隔离级别有哪些？各有哪些优缺点？</h4><details>
<summary>展开查看</summary>

<p>读取未提交：可能会脏读、不可重复读、幻读</p>
<p>读取已提交：可能会不可重复读和幻读</p>
<p>可重复读：指事务执行期间，<strong>其他事务所做的修改对当前事务都不可见</strong>，默认的事务隔离级别，幻读还有可能发生</p>
<p>可串行化：所有事务逐个执行</p>
</details>

<h4 id="简述脏读和幻读的发生场景，InnoDB-是如何解决幻读的？"><a href="#简述脏读和幻读的发生场景，InnoDB-是如何解决幻读的？" class="headerlink" title="简述脏读和幻读的发生场景，InnoDB 是如何解决幻读的？"></a>简述脏读和幻读的发生场景，InnoDB 是如何解决幻读的？</h4><details>
<summary>展开查看</summary>

<ul>
<li>脏读：一个事务对数据进行了修改，另一个事务读取了这个修改后的数据，然后前一个事务失败回滚了</li>
<li>幻读：一个事务在读取表中数据的过程中，又新插入了几行记录。</li>
</ul>
<p>通过MVCC或者临键锁（记录锁+间隙锁）防止新数据插入。</p>
</details>

<h4 id="简述什么是最左匹配原则"><a href="#简述什么是最左匹配原则" class="headerlink" title="简述什么是最左匹配原则"></a>简述什么是最左匹配原则</h4><details>
<summary>展开查看</summary>

<p>联合索引中的最左前缀匹配原则，会根据最左侧的字段过滤一批数据，直至联合索引中的字段全部匹配完成。</p>
</details>

<h4 id="简述-MySQL-MVCC-的实现原理"><a href="#简述-MySQL-MVCC-的实现原理" class="headerlink" title="简述 MySQL MVCC 的实现原理"></a>简述 MySQL MVCC 的实现原理</h4><details>
<summary>展开查看</summary>

<p>MVCC会对一份数据存储多个版本，通过undo log（这个日志会记录某行数据多个版本的数据）实现</p>
</details>

<h4 id="数据库如何设计索引，如何优化查询？"><a href="#数据库如何设计索引，如何优化查询？" class="headerlink" title="数据库如何设计索引，如何优化查询？"></a>数据库如何设计索引，如何优化查询？</h4><details>
<summary>展开查看</summary>

<ul>
<li>联合索引：对于多个列经常一起用作查询条件的情况，创建联合索引提高查询效率。</li>
<li>使用覆盖索引；对于联合索引，满足最左前缀匹配原则；避免使用函数或者%开头的like模糊查找使索引失效</li>
</ul>
</details>

<h4 id="MySQL的主从同步机制"><a href="#MySQL的主从同步机制" class="headerlink" title="MySQL的主从同步机制"></a>MySQL的主从同步机制</h4><details>
<summary>展开查看</summary>

<p>基于<strong>binlog</strong>日志的机制，实现主服务器到从服务器数据的同步。（有点像读写分离那一块的）</p>
</details>

<h4 id="sql优化手段"><a href="#sql优化手段" class="headerlink" title="sql优化手段"></a>sql优化手段</h4><details>
<summary>展开查看</summary>

<ul>
<li>避免使用select * 语句     消耗CPU、无法得到覆盖索引的优化</li>
<li>避免使用外键或者级联操作      对分库分表不友好</li>
<li>选择合适的字段类型       存储字节越少，，占用空间越小，性能也越好</li>
</ul>
</details>

<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="Redis-如何实现分布式锁？"><a href="#Redis-如何实现分布式锁？" class="headerlink" title="Redis 如何实现分布式锁？"></a>Redis 如何实现分布式锁？</h4><details>
<summary>展开查看</summary>

<ul>
<li>基于SETNX实现，它的原理是如果key存在则返回0，key不存在就创建key，这样只有第一个执行SETNX的客户端才能成功，这样第一个客户端就获取到了锁，直到锁过期释放</li>
<li>基于SET实现，SET添加了NX和EX的参数，分别起到SETNX和EXPIRE的效果</li>
<li>Redlock算法：获取当前时间，依次向5个Redis获取锁，若在3个以上成功，且获取锁的时间小于锁的有效时间，则获得锁。</li>
</ul>
<p><strong>具体实现：</strong> redission中的watch dog机制，获取锁之后会将锁的线程放入到redission维护的一个map中，每10s查询一次，若还持有锁，则会延长时间。</p>
</details>

<h4 id="简述-Redis-持久化中-RDB-以及-AOF-方案的优缺点"><a href="#简述-Redis-持久化中-RDB-以及-AOF-方案的优缺点" class="headerlink" title="简述 Redis 持久化中 RDB 以及 AOF 方案的优缺点"></a>简述 Redis 持久化中 RDB 以及 AOF 方案的优缺点</h4><details>

<summary>展开查看</summary>
RDB

<ul>
<li>高性能，通过<strong>fork子进程</strong>（savebg）完成持久化；RDB文件在指定的时间间隔内生成，而且是经过压缩的二进制数据，便于备份与恢复。</li>
<li>Redis发生故障会丢失最近的一次快照；持久化是周期性的，不能保证每个操作都持久化到磁盘，不适用于实时持久化</li>
</ul>
<p>AOF</p>
<ul>
<li>AOF持久化记录了每个操作命令，可以确保Redis数据的完整性，即使发生故障也能恢复；几乎是实时记录每个写操作，适用于<strong>实时持久化</strong></li>
<li>AOF文件比RDB大很多，重写也会消耗资源；恢复数据需要依次执行每个写命令，速度非常慢。</li>
</ul>
</details>

<h4 id="简述-Redis-中常见类型的底层数据结构"><a href="#简述-Redis-中常见类型的底层数据结构" class="headerlink" title="简述 Redis 中常见类型的底层数据结构"></a>简述 Redis 中常见类型的底层数据结构</h4><details>
<summary>展开查看</summary>

<p>String（SDS）、Hash、List、Set、Zset（跳表）</p>
</details>

<h4 id="为什么-Redis-在单线程下能如此快？"><a href="#为什么-Redis-在单线程下能如此快？" class="headerlink" title="为什么 Redis 在单线程下能如此快？"></a>为什么 Redis 在单线程下能如此快？</h4><details>
<summary>展开查看</summary>

<p>读写命令是单线程，但通过<strong>非阻塞IO多路复用程序</strong>来监听多个套接字，通过单线程处理多个客户端的请求，减少了线程切换和同步开销。</p>
</details>

<h4 id="简述-Redis-的线程模型以及底层架构设计"><a href="#简述-Redis-的线程模型以及底层架构设计" class="headerlink" title="简述 Redis 的线程模型以及底层架构设计"></a>简述 Redis 的线程模型以及底层架构设计</h4><details>
<summary>展开查看</summary>

<p>基于<strong>Reactor</strong>模式（核心就是非阻塞IO）设计了<strong>文件事件处理器</strong>，非阻塞IO多路复用程序和多个客户端都是这个处理器的一部分。</p>
<p>读写命令都是单线程，多线程体现在网络数据的读写。</p>
</details>

<h4 id="简述-Redis-的过期机制和内存淘汰策略"><a href="#简述-Redis-的过期机制和内存淘汰策略" class="headerlink" title="简述 Redis 的过期机制和内存淘汰策略"></a>简述 Redis 的过期机制和内存淘汰策略</h4><details>
<summary>展开查看</summary>

<p>过期机制：定期清理和惰性清理</p>
<p>内存淘汰策略：lru、ttl、random</p>
</details>

<h4 id="简述-Redis-的哨兵机制"><a href="#简述-Redis-的哨兵机制" class="headerlink" title="简述 Redis 的哨兵机制"></a>简述 Redis 的哨兵机制</h4><details>
<summary>展开查看</summary>

<p>它主要用于监控 Redis 主从服务器的运行状态，自动完成故障转移（failover），并通过订阅和通知机制告知客户端关于 Redis 系统状态的变化。</p>
<p><strong>选举过程</strong>：当哨兵发现主节点失效时，它会在哨兵系统中发起选举，选出一个哨兵作为领导者来执行自动故障转移的操作。</p>
</details>

<h4 id="简述-Redis-如何处理热点-key-访问"><a href="#简述-Redis-如何处理热点-key-访问" class="headerlink" title="简述 Redis 如何处理热点 key 访问"></a>简述 Redis 如何处理热点 key 访问</h4><details>
<summary>展开查看</summary>

<p>读写分离，分为读节点和写节点</p>
<p>Redis cluster：热点数据分散存储在多个Redis节点上</p>
</details>

<h4 id="简述-Redis-中如何防止缓存雪崩和缓存击穿和缓存穿透"><a href="#简述-Redis-中如何防止缓存雪崩和缓存击穿和缓存穿透" class="headerlink" title="简述 Redis 中如何防止缓存雪崩和缓存击穿和缓存穿透"></a>简述 Redis 中如何防止缓存雪崩和缓存击穿和缓存穿透</h4><details>
<summary>展开查看</summary>

<p>缓存穿透：缓存无效key，设置布隆过滤器（把所有可能出现的值存入布隆过滤器，01存储）</p>
<p>缓存雪崩：Redis中多个key同时过期或者Redis崩溃，导致数据库请求量暴增  针对Redis崩溃，可以采用Redis集群或者限流；针对热点key过期，参考缓存击穿；针对大量key同时过期，给key设置随机过期时间或者lazy-free策略（采用异步方式释放过期的key）</p>
<p>缓存击穿：Redis热点key过期，导致数据库请求量暴增    缓存提前预热，设置永不过期（不推荐）</p>
</details>

<h4 id="简述-Redis-中跳表的应用以及优缺点"><a href="#简述-Redis-中跳表的应用以及优缺点" class="headerlink" title="简述 Redis 中跳表的应用以及优缺点"></a>简述 Redis 中跳表的应用以及优缺点</h4><details>
<summary>展开查看</summary>

<p>跳表是ZSet的底层实现，相比于平衡树和红黑树，它有更好的区间查找效率，不需要像平衡树和红黑树要通过旋转维持平衡，缺点是跳表会在多个层次上存储节点的索引，空间开销大。</p>
</details>

<h4 id="简述-Redis-集群配置以及基础原理"><a href="#简述-Redis-集群配置以及基础原理" class="headerlink" title="简述 Redis 集群配置以及基础原理"></a>简述 Redis 集群配置以及基础原理</h4><details>
<summary>展开查看</summary>

<p>Redis集群包含多个节点，这些节点通过网络连接形成集群。每个节点都配置有自己的IP地址和端口号，以便集群中的其他节点可以与之通信。节点之间的通信使用TCP连接，并且这些连接是永久保持的。</p>
</details>

<h4 id="redis高可用的做法"><a href="#redis高可用的做法" class="headerlink" title="redis高可用的做法"></a>redis高可用的做法</h4><details>
<summary>展开查看</summary>

<p>高可用是指系统在面对各种故障情况下，保持长时间的可用性和稳定性。</p>
<ul>
<li>主从复制：redis集群中分为主节点和从节点，主从复制是指将一个 Redis 服务器（主节点）的数据复制到其他 Redis 服务器（从节点）上。主从复制提供了数据冗余备份、读写分离以及故障恢复等功能。</li>
<li>哨兵机制：主要用于监控 Redis 主从服务器的运行状态，自动完成故障转移。当哨兵发现主节点失效时，它会在哨兵系统中发起选举，选出一个哨兵作为领导者来执行自动故障转移的操作。</li>
<li>持久化：ROB和AOF方式实现持久化</li>
</ul>
</details>

<h3 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h3><h4 id="消息模型和组件"><a href="#消息模型和组件" class="headerlink" title="消息模型和组件"></a>消息模型和组件</h4><details>
<summary>展开查看</summary>

<p>早期使用的是队列模型，使用队列作为消息通信载体，但是使用队列有一些问题，一条消息只能被一个消费者使用，如果我想多个消费者消费同一条消息（广播），则实现不了。</p>
<p>现在使用的是<strong>发布-订阅模型</strong>，使用主题topic作为消息通信载体，一个生产者发布了一个主题，则所有订阅了这个主题的消费者都能接收到消息（广播），当只有一个消费者的时候，就退化成了队列模型。</p>
<p><strong>组件：</strong>生产者、消费者、话题、broker代理、partition分区</p>
<p>一个broker中可以有多个topic，一个topic中可以有多个partition</p>
</details>

<h4 id="kafka怎么保证消息消费的顺序"><a href="#kafka怎么保证消息消费的顺序" class="headerlink" title="kafka怎么保证消息消费的顺序"></a>kafka怎么保证消息消费的顺序</h4><details>
<summary>展开查看</summary>

<p>一个topic中可能有多个partition，消息被追加到partition中会计算偏移量，然后放入partition，如果有多个partition，并不能保证先存入的消息先被消费。</p>
<p>有两种方法：1、一个topic中只有一个partition，2、生产者将消息放入消息队列时指定key或者partition。</p>
</details>

<h4 id="kafka怎么保证消息不丢失"><a href="#kafka怎么保证消息不丢失" class="headerlink" title="kafka怎么保证消息不丢失"></a>kafka怎么保证消息不丢失</h4><details>
<summary>展开查看</summary>

<ul>
<li>生产者</li>
</ul>
<p>因为网络原因，生产者发送失败。      会重试，0间隔重试10次，若重试失败消息会进入死信队列，死信队列有两种处理方式：为死信队列设置一个专门的消息处理器，处理方法比如记录日志、发送警报或通知；重新消费这些消息。</p>
<ul>
<li>消费者</li>
</ul>
<p>当消费者拉取到partition的某个消息之后，消费者会自动提交offset，如果消费者刚拿到消息时突然挂掉了，则这条消息就丢失了。自动提交offset——&gt;手动提交，但是可能出现重复消费的问题。</p>
<ul>
<li>kafka服务器</li>
</ul>
<p>kafka为partition引入了多副本机制，多个副本之间会有个leader，除了leader其他称作follower，发送的消息会被发送到leader上，然后follower会从leader中拉取消息同步，如果leader挂掉的时候，还有follower没有同步，则丢失了消息。</p>
<p>可以设置acks &#x3D; all，这样所有follower都同步消息之后才会响应服务器。</p>
</details>

<h4 id="kafka如何保证消息不重复消费"><a href="#kafka如何保证消息不重复消费" class="headerlink" title="kafka如何保证消息不重复消费"></a>kafka如何保证消息不重复消费</h4><details>
<summary>展开查看</summary>

<p>根本原因：消费者端已经消费的消息没有成功提交offset</p>
<p>解决方法：消费消息服务做幂等校验，比如Redis的set，MySQL的主键等天然的幂等功能。</p>
</details>

<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="网络分层模型"><a href="#网络分层模型" class="headerlink" title="网络分层模型"></a>网络分层模型</h4><h5 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h5><details>
<summary>展开查看</summary>

<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/osi-7-model.png" alt="OSI 七层模型"></p>
</details>

<h5 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP&#x2F;IP四层模型"></a>TCP&#x2F;IP四层模型</h5><details>
<summary>展开查看</summary>

<ol>
<li>应用层（应用层、表示层、会话层）</li>
<li>传输层</li>
<li>网络层</li>
<li>网络接口层（数据链路层、物理层）</li>
</ol>
</details>

<h4 id="打开一个网站，会用到哪些协议"><a href="#打开一个网站，会用到哪些协议" class="headerlink" title="打开一个网站，会用到哪些协议"></a>打开一个网站，会用到哪些协议</h4><details>
<summary>展开查看</summary>

<ol>
<li>在浏览器中输入网页的URL</li>
<li>浏览器通过DNS协议，获取域名对应的IP地址；</li>
<li>浏览器根据IP和端口号，向目标服务器发起一个TCP请求</li>
<li>浏览器在TCP连接上，向服务器发送一个HTTP请求，请求获取网页的内容</li>
<li>服务器收到HTTP请求后，会发一个HTTP响应报文给浏览器</li>
<li>浏览器收到HTTP响应后，解析响应体中的HTML样式，同时根据HTML中其他资源（图片、CSS、js）的URL再次发起HTTP请求，直至网页资源全部加载</li>
</ol>
</details>

<h4 id="HTTP和HTTPS有什么区别"><a href="#HTTP和HTTPS有什么区别" class="headerlink" title="HTTP和HTTPS有什么区别"></a>HTTP和HTTPS有什么区别</h4><details>
<summary>展开查看</summary>

<ul>
<li>端口号：HTTP默认是80，HTTPs默认是443</li>
<li>URL前缀</li>
<li>安全性：HTTPS运行在SSL&#x2F;TLS协议上，SSL&#x2F;TLS运行在TCP上，所有传输的内容都经过加密。</li>
</ul>
</details>

<h4 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h4><details>
<summary>展开查看</summary>

<ul>
<li>GET通常用于获取或查询资源，POST用于创建或修改资源；</li>
<li>GET是幂等的，POST是不幂等的</li>
<li>GET请求的参数放在URL中，POST请求的参数放在请求体中</li>
<li>GET可以被缓存，POST不行</li>
</ul>
</details>

<h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><details>
<summary>展开查看</summary>

<table>
<thead>
<tr>
<th></th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td>是否面向连接</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否可靠</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否有状态</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>传输效率</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>传输形式</td>
<td>字节流</td>
<td>数据报文段</td>
</tr>
<tr>
<td>首部开销</td>
<td>20-60 bytes</td>
<td>8bytes</td>
</tr>
<tr>
<td>是否支持多播或广播</td>
<td>点对点</td>
<td>一对一，一对多，多对多</td>
</tr>
<tr>
<td>应用</td>
<td>文件传输、远程登录</td>
<td>即时通信、直播</td>
</tr>
</tbody></table>
</details>

<h4 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a>TCP的三次握手和四次挥手</h4><h5 id="三次挥手"><a href="#三次挥手" class="headerlink" title="三次挥手"></a>三次挥手</h5><details>
<summary>展开查看</summary>

<ol>
<li>客户端向服务端发送一个SYN(SEQ &#x3D; x)的请求报文；</li>
<li>服务端在接收之后向客户端发送一个SYN(SEQ&#x3D;y)和一个ACK(ACK &#x3D; x+1)报文；</li>
<li>客户端在接收之后向服务端发送一个ACK(ACK&#x3D;y+1)报文。</li>
</ol>
<p>第一次握手之后，服务端确定了客户端发送正常，自己接收正常；</p>
<p>第二次握手之后，客户端确定了自己发送和接收正常，服务端接收和发送正常，服务端确定了自己接收正常，客户端发送正常；</p>
<p>第三次握手之后，客户端确定了自己发送和接收正常，服务端接收和发送正常，服务端确定了自己发送和接收正常，客户端发送和接收正常；</p>
<p>建立连接。</p>
</details>

<h5 id="四次握手"><a href="#四次握手" class="headerlink" title="四次握手"></a>四次握手</h5><details>
<summary>展开查看</summary>

<ol>
<li>客户端向服务端发送一个FIN(SEQ&#x3D;x)的请求报文；</li>
<li>服务端在接收之后向客户端发送一个ACK(ACK&#x3D;x+1)报文；</li>
<li>服务端向客户端发送一个FIN(SEQ&#x3D;y)的请求报文；</li>
<li>客户端在接收之后向服务端发送一个ACK(ACK&#x3D;y+1)报文，客户端等待若干时间，若服务端无响应，则关闭连接。</li>
</ol>
<p>前两次挥手是客户端表明要断开连接，后两次挥手是服务端确定要断开连接。</p>
</details>

<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h4 id="线程间的同步方式"><a href="#线程间的同步方式" class="headerlink" title="线程间的同步方式"></a>线程间的同步方式</h4><details>
<summary>展开查看</summary>

<ul>
<li>互斥锁</li>
<li>读写锁</li>
<li>信号量</li>
<li>屏障       同步原语，等待多个线程到达某个点再一起继续执行</li>
<li>事件       通知的方式保持线程同步</li>
</ul>
</details>

<h4 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h4><details>
<summary>展开查看</summary>

<ul>
<li>管道</li>
<li>信号</li>
<li>消息队列</li>
<li>信号量</li>
<li>共享内存</li>
<li>套接字</li>
</ul>
</details>

<h4 id="进程的调度算法"><a href="#进程的调度算法" class="headerlink" title="进程的调度算法"></a>进程的调度算法</h4><details>
<summary>展开查看</summary>

<ul>
<li><strong>先到先服务调度算法(FCFS，First Come, First Served)</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>短作业优先的调度算法(SJF，Shortest Job First)</strong> : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>时间片轮转调度算法（RR，Round-Robin）</strong> : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li>
<li><strong>多级反馈队列调度算法（MFQ，Multi-level Feedback Queue）</strong>：前面介绍的几种进程调度的算法都有一定的局限性。如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong> 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</li>
<li><strong>优先级调度算法（Priority）</strong>：为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li>
</ul>
</details>

<h4 id="僵尸进程与孤儿进程"><a href="#僵尸进程与孤儿进程" class="headerlink" title="僵尸进程与孤儿进程"></a>僵尸进程与孤儿进程</h4><details>
<summary>展开查看</summary>

<p>子进程通常是通过 fork()系统调用创建的，该调用会创建一个新的进程，该进程是原有进程的一个副本。子进程和父进程的运行是相互独立的，它们各自拥有自己的 PCB，即使父进程结束了，子进程仍然可以继续运行。</p>
<ul>
<li><strong>僵尸进程：</strong>子进程已经终止，但是其父进程仍在运行，父进程没有调用wait()系统调用来释放子进程占用的资源。</li>
<li><strong>孤儿进程：</strong>父进程已经终止，但是子进程仍在运行。</li>
</ul>
</details>

<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><details>
<summary>展开查看</summary>

<p>多个线程&#x2F;进程同时被阻塞，都在等待某个资源被释放</p>
</details>

<h5 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a>死锁的四个必要条件</h5><details>
<summary>展开查看</summary>

<ul>
<li>互斥</li>
<li>占用并等待</li>
<li>非抢占</li>
<li>循环等待</li>
</ul>
</details>

<h5 id="模拟死锁的代码"><a href="#模拟死锁的代码" class="headerlink" title="模拟死锁的代码"></a>模拟死锁的代码</h5><details>
<summary>展开查看</summary>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 1&quot;</span>).start();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</details>

<h5 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h5><h6 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h6><details>
<summary>展开查看</summary>

<ul>
<li>静态分配策略    一个进程在执行前申请到它所需要的所有资源      破坏了占用并等待条件</li>
<li>层次分配策略    一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程<br>要释放某层的一个资源时，必须先释放所占用的较高层的资源，破坏了循环等待条件</li>
</ul>
</details>

<h6 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h6><details>
<summary>展开查看</summary>

<p>当一个进程申请使用资源的时候，<strong>银行家算法</strong> 通过先 <strong>试探</strong> 分配给该进程资源，然后通过 <strong>安全性算法</strong> 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 <strong>真的分配资源给该进程</strong>。</p>
</details>

<h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>MTR课表小程序是和组里同学和师兄一起开发的java项目，初衷是帮南理工的同学们查询课表、成绩等教务信息。主要的技术栈是springboot、mybatis-plus、redis、mysql、elasticsearch和kafka。</p>
<p>原来查询课表或者成绩都需要登录学校的教务网站，在手机上操作不太方便而且比较耗时，为了快捷且便利的查看课表，查询成绩、空教室以及校内交流，开发了这个微信小程序。</p>
<h3 id="我的工作"><a href="#我的工作" class="headerlink" title="我的工作"></a>我的工作</h3><p>我主要实现了登录模块和校内论坛模块</p>
<h4 id="登录模块"><a href="#登录模块" class="headerlink" title="登录模块"></a>登录模块</h4><p>第一个版本使用的是最常规的Session的登录方式（session-localStorage方案），后来改了多服务器以后，Session这种方式就出现了问题，首先就是Session不共享的问题。</p>
<p>我们最后选择了JWT（json web token），解决了Session共享的问题，用户登陆时，服务器端生成一个token令牌响应给前端。后续的请求中需要携带令牌到服务器端，服务器端可以解析token，得到用户信息做校验。jwt令牌会存在localstorage（本地浏览器）中，不需要总是重新登录</p>
<p><a target="_blank" rel="noopener" href="https://fangjun120.github.io/2023/11/12/11-00-37/">jwt</a>是目前最流行的跨域认证的解决方案，是基于token的认证授权机制。本质是一组字符串，由3个部分组成。jwt会将用户id和一些其他信息包装起来一起编码。</p>
<h5 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h5><p>跨站请求伪造，用你的身份去发送一些对你不友好的请求，通过点击非法链接，如果是cookie的话会带到链接中去，伪造者可以利用这个cookie进行非法操作，但是我们将jwt放入localstorage，就不会跟着cookie带到链接里面去。</p>
<h5 id="如何获得教务信息"><a href="#如何获得教务信息" class="headerlink" title="如何获得教务信息"></a>如何获得教务信息</h5><p>学校教务有一个统一的入口，通过登录教务系统拿到一个cookie，再通过cookie访问课表、成绩等信息。</p>
<h5 id="获取用户信息"><a href="#获取用户信息" class="headerlink" title="获取用户信息"></a>获取用户信息</h5><p>ThreadLocal 并不是一个Thread，而是Thread的局部变量。<br>ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。</p>
<p>可以用threalocal的set方法去存用户的信息，然后用get方法获取当前线程下的信息，不需要加锁。</p>
<h5 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h5><p>用了三台2核4g的服务器，做nginx反向代理，采用轮询的方式做负载均衡。</p>
<h4 id="论坛模块"><a href="#论坛模块" class="headerlink" title="论坛模块"></a>论坛模块</h4><h5 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h5><p>帖子表：帖子id、发布者id、标题、内容、发布时间、评论数量</p>
<p>评论表：评论id、帖子id、评论用户id、评论时间、内容、回复用户id</p>
<p>评论图片表：帖子id、图片链接</p>
<h5 id="评论实现方式"><a href="#评论实现方式" class="headerlink" title="评论实现方式"></a>评论实现方式</h5><p>把评论和回复都当做评论，按时间排序。因为我们回复评论的情况较少，实现起来也比较简单。</p>
<h5 id="多线程评论数量不同步"><a href="#多线程评论数量不同步" class="headerlink" title="多线程评论数量不同步"></a>多线程评论数量不同步</h5><p>我一开始使用的是sycronized锁，来实现单机的锁，这样可以不用管锁的获取和释放，挺方便的。后来因为使用了多个服务器，单机锁不适用了，后来想起来sycronized的轻量级锁，想想直接使用乐观锁的方式来实现也可以，利用mysql自己的行锁写锁，在更新操作的时候在where上多加一个条件，如果更新失败，就睡一下，然后重试。这种实现方式在高并发的时候效率并不高，因为如果出现同步问题的时候，锁是在数据库的，相当于在磁盘上，效率并不高。</p>
<p>使用了redis的<strong>分布式锁</strong>，原本打算用<strong>setnx</strong>做一个简单的分布式锁。考虑到可能出现客户端宕机，没有释放锁，导致死锁。于是加了<strong>过期时间</strong>。</p>
<p>通过记录当前的机器+线程id，避免把别人的锁给释放了。</p>
<p>锁过期了怎么解决？通过redission的watch dog机制，获取锁之后会将锁的线程放入到redission维护的一个map中，每隔10s检查一下，若还持有则会延长时间。</p>
<p>锁的释放可以手动释放也可以定期释放。</p>
<h5 id="ElasticSearch全文搜索并高亮"><a href="#ElasticSearch全文搜索并高亮" class="headerlink" title="ElasticSearch全文搜索并高亮"></a>ElasticSearch全文搜索并高亮</h5><p>es类似于数据库，es中的索引表示数据库中的一个表，当新增数据时（比如帖子表），es会将其中的标题和内容写入到索引中，以便于搜索，对数据进行更新或者删除时，也会对索引中的数据进行处理。</p>
<p>当新建帖子时，会将帖子对象中的标题和内容字段异步写入到es中，这里首先是更新数据库，然后将内容写入消息字段，等待消费者将其写入es;如果es写入失败了，会再次加入到消息队列中。</p>
<p>当删除帖子时，会先删数据库，然后异步删除es中的内容，如果删除失败也是再加入消息队列。</p>
<p><strong>高亮的实现</strong>  重写elasticsearchtemplate类中的mapresults方法。</p>
<p><strong>es和redis底层都用的netty，这两者启动时会冲突，主要是es会检查netty是否初始化，解决方案通过系统设置es底层检查netty是否初始化的参数，设置为false</strong></p>
<h5 id="kafka实现系统通知"><a href="#kafka实现系统通知" class="headerlink" title="kafka实现系统通知"></a>kafka实现系统通知</h5><p>对于评论、点赞和关注三种通知，分别设置不同的topic，生产者线程只负责将这些行为写入到消息队列中，消费者线程会从消息队列中取出消息进行处理。</p>
<p>从业务层面来说，上面的行为封装成一个事件的实体类，让这个实体类内中封装消费者可能需要的数据，然后让实体类的对象作为消息（这里是将对象转为json字符串）写入到消息队列中去。消费者线程从消息队列中取出消息写入到数据库中，让系统通知到用户，进入通知界面，会对message表进行查询。</p>
<p>如果要实现实时的通知，则消费者线程从消息队列中取出消息后就直接通过websocket推送给前端。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jiangduwang.github.io/2024/04/02/%E7%AE%80%E5%8E%86%E5%85%AB%E8%82%A1%E5%86%85%E5%AE%B9/" data-id="clutj1iwu0002l8ul74j49fic" data-title="面试八股内容" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/02/hello-world/" class="article-date">
  <time class="dt-published" datetime="2024-04-02T08:02:56.852Z" itemprop="datePublished">2024-04-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/02/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jiangduwang.github.io/2024/04/02/hello-world/" data-id="clutj1iwo0000l8ul9bbu7xxh" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/04/10/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/">测试开发八股</a>
          </li>
        
          <li>
            <a href="/2024/04/02/%E7%AE%80%E5%8E%86%E5%85%AB%E8%82%A1%E5%86%85%E5%AE%B9/">面试八股内容</a>
          </li>
        
          <li>
            <a href="/2024/04/02/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 jiangduwang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>